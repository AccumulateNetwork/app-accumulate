#pragma once

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif
#include <common/encoding.h>

typedef struct {
   const char *name;
   uint32_t e;
} enum_t;



typedef enum {

    // AccountTypeUnknown represents an unknown account type.
    AccountTypeUnknown = 0,

    // AccountTypeAnchor is one or more Merkle DAG anchors.
    AccountTypeAnchor = 1,

    // AccountTypeIdentity is an Identity account, aka an ADI.
    AccountTypeIdentity = 2,

    // AccountTypeTokenIssuer is a Token Issuer account.
    AccountTypeTokenIssuer = 3,

    // AccountTypeTokenAccount is an ADI Token Account.
    AccountTypeTokenAccount = 4,

    // AccountTypeLiteTokenAccount is a Lite Token Account.
    AccountTypeLiteTokenAccount = 5,

    // AccountTypeTransaction is a completed transaction.
    AccountTypeTransaction = 7,

    // AccountTypePendingTransaction is a pending transaction.
    AccountTypePendingTransaction = 8,

    // AccountTypeKeyPage is a Key Page account.
    AccountTypeKeyPage = 9,

    // AccountTypeKeyBook is a Key Book account.
    AccountTypeKeyBook = 10,

    // AccountTypeDataAccount is an ADI Data Account.
    AccountTypeDataAccount = 11,

    // AccountTypeLiteDataAccount is a Lite Data Account.
    AccountTypeLiteDataAccount = 12,

    // AccountTypeInternalLedger is a ledger that tracks the state of internal operations.
    AccountTypeInternalLedger = 14,

} AccountType;


typedef enum {

    // ChainTypeUnknown is used when the chain type is not known.
    ChainTypeUnknown = 0,

    // ChainTypeTransaction holds transaction hashes.
    ChainTypeTransaction = 1,

    // ChainTypeAnchor holds chain anchors.
    ChainTypeAnchor = 2,

    // ChainTypeData holds data entry hashes.
    ChainTypeData = 3,

} ChainType;


typedef enum {

    // KeyPageOperationUnknown is used when the key page operation is not known.
    KeyPageOperationUnknown = 0,

    // KeyPageOperationUpdate replaces a key in the page with a new key.
    KeyPageOperationUpdate = 1,

    // KeyPageOperationRemove removes a key from the page.
    KeyPageOperationRemove = 2,

    // KeyPageOperationAdd adds a key to the page.
    KeyPageOperationAdd = 3,

    // KeyPageOperationSetThreshold sets the signing threshold (the M of "M of N" signatures required).
    KeyPageOperationSetThreshold = 4,

} KeyPageOperation;


typedef enum {

    // ObjectTypeUnknown is used when the object type is not known.
    ObjectTypeUnknown = 0,

    // ObjectTypeAccount represents an account object.
    ObjectTypeAccount = 1,

    // ObjectTypeTransaction represents a transaction object.
    ObjectTypeTransaction = 2,

} ObjectType;


typedef enum {

    // TransactionMaxUser is the highest number reserved for user transactions.
    TransactionMaxUser = 47,

    // TransactionMaxSynthetic is the highest number reserved for synthetic transactions.
    TransactionMaxSynthetic = 95,

    // TransactionMaxInternal is the highest number reserved for internal transactions.
    TransactionMaxInternal = 255,

} TransactionMax;


typedef enum {

    // TransactionTypeUnknown represents an unknown transaction type.
    TransactionTypeUnknown = 0,

    // TransactionTypeCreateIdentity creates an ADI, which produces a synthetic chain.
    TransactionTypeCreateIdentity = 1,

    // TransactionTypeCreateTokenAccount creates an ADI token account, which produces a synthetic chain create transaction.
    TransactionTypeCreateTokenAccount = 2,

    // TransactionTypeSendTokens transfers tokens between token accounts, which produces a synthetic deposit tokens transaction.
    TransactionTypeSendTokens = 3,

    // TransactionTypeCreateDataAccount creates an ADI Data Account, which produces a synthetic chain create transaction.
    TransactionTypeCreateDataAccount = 4,

    // TransactionTypeWriteData writes data to an ADI Data Account, which *does not* produce a synthetic transaction.
    TransactionTypeWriteData = 5,

    // TransactionTypeWriteDataTo writes data to a Lite Data Account, which produces a synthetic write data transaction.
    TransactionTypeWriteDataTo = 6,

    // TransactionTypeAcmeFaucet produces a synthetic deposit tokens transaction that deposits ACME tokens into a lite token account.
    TransactionTypeAcmeFaucet = 7,

    // TransactionTypeCreateToken creates a token issuer, which produces a synthetic chain create transaction.
    TransactionTypeCreateToken = 8,

    // TransactionTypeIssueTokens issues tokens to a token account, which produces a synthetic token deposit transaction.
    TransactionTypeIssueTokens = 9,

    // TransactionTypeBurnTokens burns tokens from a token account, which produces a synthetic burn tokens transaction.
    TransactionTypeBurnTokens = 10,

    // TransactionTypeCreateKeyPage creates a key page, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyPage = 12,

    // TransactionTypeCreateKeyBook creates a key book, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyBook = 13,

    // TransactionTypeAddCredits converts ACME tokens to credits, which produces a synthetic deposit credits transaction.
    TransactionTypeAddCredits = 14,

    // TransactionTypeUpdateKeyPage adds, removes, or updates keys in a key page, which *does not* produce a synthetic transaction.
    TransactionTypeUpdateKeyPage = 15,

    // TransactionTypeSignPending is used to sign a pending transaction.
    TransactionTypeSignPending = 48,

    // TransactionTypeSyntheticCreateChain creates or updates chains.
    TransactionTypeSyntheticCreateChain = 49,

    // TransactionTypeSyntheticWriteData writes data to a data account.
    TransactionTypeSyntheticWriteData = 50,

    // TransactionTypeSyntheticDepositTokens deposits tokens into token accounts.
    TransactionTypeSyntheticDepositTokens = 51,

    // TransactionTypeSyntheticAnchor anchors one network to another.
    TransactionTypeSyntheticAnchor = 52,

    // TransactionTypeSyntheticDepositCredits deposits credits into a credit holder.
    TransactionTypeSyntheticDepositCredits = 53,

    // TransactionTypeSyntheticBurnTokens returns tokens to a token issuer's pool of issuable tokens.
    TransactionTypeSyntheticBurnTokens = 54,

    // TransactionTypeSyntheticMirror mirrors records from one network to another.
    TransactionTypeSyntheticMirror = 56,

    // TransactionTypeSegWitDataEntry is a surrogate transaction segregated witness for a WriteData transaction.
    TransactionTypeSegWitDataEntry = 57,

    // TransactionTypeInternalGenesis initializes system chains.
    TransactionTypeInternalGenesis = 96,

    // TransactionTypeInternalSendTransactions reserved for internal send.
    TransactionTypeInternalSendTransactions = 97,

    // TransactionTypeInternalTransactionsSigned notifies the executor of synthetic transactions that have been signed.
    TransactionTypeInternalTransactionsSigned = 98,

    // TransactionTypeInternalTransactionsSent notifies the executor of synthetic transactions that have been sent.
    TransactionTypeInternalTransactionsSent = 99,

} TransactionType;




typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, AccountType *out);
    Error (*set)(struct Bytes *, AccountType in);
} AccountType_t;

ACME_API Error AccountType_valid(const Bytes *v);
ACME_API Error AccountType_set(Bytes *v, AccountType n);
ACME_API Error AccountType_get(const Bytes *v, AccountType *n);
ACME_API uint64_t AccountType_ID(AccountType v);
ACME_API Error AccountType_fromString(Bytes *v, String *name);
ACME_API Error AccountType_asString(const Bytes *v, String *out);
ACME_API Error AccountType_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error AccountType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error AccountType_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error AccountType_unmarshalBinary(Bytes *v, const Marshaler *in);
AccountType_t AccountType_init(AccountType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error AccountType_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof(AccountType)) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error AccountType_set(Bytes *v, AccountType n) {
    Error e = AccountType_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error AccountType_get(const Bytes *v, AccountType *n) {
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *(AccountType*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the Account Type
ACME_API uint64_t AccountType_ID(AccountType v) { return (uint64_t)(v); }

// String returns the name of the Account Type
static enum_t AccountType_l[] = {
	{ "unknown", AccountTypeUnknown },
	{ "anchor", AccountTypeAnchor },
	{ "identity", AccountTypeIdentity },
	{ "tokenIssuer", AccountTypeTokenIssuer },
	{ "tokenAccount", AccountTypeTokenAccount },
	{ "liteTokenAccount", AccountTypeLiteTokenAccount },
	{ "transaction", AccountTypeTransaction },
	{ "pendingTransaction", AccountTypePendingTransaction },
	{ "keyPage", AccountTypeKeyPage },
	{ "keyBook", AccountTypeKeyBook },
	{ "dataAccount", AccountTypeDataAccount },
	{ "liteDataAccount", AccountTypeLiteDataAccount },
	{ "internalLedger", AccountTypeInternalLedger },
};

ACME_API Error AccountType_asString(const Bytes *v, String *out) {
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    AccountType val = *(AccountType*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof(AccountType_l); ++i ) {
        if ( AccountType_l[i].e == val ) {
            out->set(&out->data, AccountType_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// AccountTypeByName returns the named Account Type.
ACME_API Error AccountType_fromString(Bytes *v, String *name) {
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof(AccountType_l); ++i ) {
        if ( strncmp(AccountType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *(AccountType*)(v->buffer.ptr + v->buffer.offset) = AccountType_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// AccountType_marshalJSON marshals the Account Type to JSON as a string.
ACME_API Error AccountType_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = AccountType_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// AccountType_unmarshalJSON unmarshals the Account Type from JSON as a string.
ACME_API Error AccountType_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return AccountType_fromString(v, &s);
}

// MarshalBinary marshals the Account Type to bytes as a unsigned varint.
ACME_API Error AccountType_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    AccountType n;
    e = AccountType_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the Account Type from bytes as a unsigned varint.
ACME_API Error AccountType_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = AccountType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	AccountType_set(v,(AccountType)t);
	return ErrorCode[ErrorNone];
}

// AccountType_binarySize returns the number of bytes required to binary marshal the Account Type.
AccountType_t AccountType_init(AccountType_t *v, buffer_t *buffer) {
    AccountType_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    AccountType_marshalBinary,
                    AccountType_unmarshalBinary,
                    AccountType_marshalJSON,
                    AccountType_unmarshalJSON},
                    AccountType_get,
                    AccountType_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof(AccountType);
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, ChainType *out);
    Error (*set)(struct Bytes *, ChainType in);
} ChainType_t;

ACME_API Error ChainType_valid(const Bytes *v);
ACME_API Error ChainType_set(Bytes *v, ChainType n);
ACME_API Error ChainType_get(const Bytes *v, ChainType *n);
ACME_API uint64_t ChainType_ID(ChainType v);
ACME_API Error ChainType_fromString(Bytes *v, String *name);
ACME_API Error ChainType_asString(const Bytes *v, String *out);
ACME_API Error ChainType_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error ChainType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error ChainType_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error ChainType_unmarshalBinary(Bytes *v, const Marshaler *in);
ChainType_t ChainType_init(ChainType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error ChainType_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof(ChainType)) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error ChainType_set(Bytes *v, ChainType n) {
    Error e = ChainType_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error ChainType_get(const Bytes *v, ChainType *n) {
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *(ChainType*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the Chain Type
ACME_API uint64_t ChainType_ID(ChainType v) { return (uint64_t)(v); }

// String returns the name of the Chain Type
static enum_t ChainType_l[] = {
	{ "unknown", ChainTypeUnknown },
	{ "transaction", ChainTypeTransaction },
	{ "anchor", ChainTypeAnchor },
	{ "data", ChainTypeData },
};

ACME_API Error ChainType_asString(const Bytes *v, String *out) {
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    ChainType val = *(ChainType*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof(ChainType_l); ++i ) {
        if ( ChainType_l[i].e == val ) {
            out->set(&out->data, ChainType_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// ChainTypeByName returns the named Chain Type.
ACME_API Error ChainType_fromString(Bytes *v, String *name) {
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof(ChainType_l); ++i ) {
        if ( strncmp(ChainType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *(ChainType*)(v->buffer.ptr + v->buffer.offset) = ChainType_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// ChainType_marshalJSON marshals the Chain Type to JSON as a string.
ACME_API Error ChainType_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = ChainType_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// ChainType_unmarshalJSON unmarshals the Chain Type from JSON as a string.
ACME_API Error ChainType_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return ChainType_fromString(v, &s);
}

// MarshalBinary marshals the Chain Type to bytes as a unsigned varint.
ACME_API Error ChainType_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    ChainType n;
    e = ChainType_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the Chain Type from bytes as a unsigned varint.
ACME_API Error ChainType_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ChainType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	ChainType_set(v,(ChainType)t);
	return ErrorCode[ErrorNone];
}

// ChainType_binarySize returns the number of bytes required to binary marshal the Chain Type.
ChainType_t ChainType_init(ChainType_t *v, buffer_t *buffer) {
    ChainType_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    ChainType_marshalBinary,
                    ChainType_unmarshalBinary,
                    ChainType_marshalJSON,
                    ChainType_unmarshalJSON},
                    ChainType_get,
                    ChainType_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof(ChainType);
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, KeyPageOperation *out);
    Error (*set)(struct Bytes *, KeyPageOperation in);
} KeyPageOperation_t;

ACME_API Error KeyPageOperation_valid(const Bytes *v);
ACME_API Error KeyPageOperation_set(Bytes *v, KeyPageOperation n);
ACME_API Error KeyPageOperation_get(const Bytes *v, KeyPageOperation *n);
ACME_API uint64_t KeyPageOperation_ID(KeyPageOperation v);
ACME_API Error KeyPageOperation_fromString(Bytes *v, String *name);
ACME_API Error KeyPageOperation_asString(const Bytes *v, String *out);
ACME_API Error KeyPageOperation_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error KeyPageOperation_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error KeyPageOperation_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error KeyPageOperation_unmarshalBinary(Bytes *v, const Marshaler *in);
KeyPageOperation_t KeyPageOperation_init(KeyPageOperation_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error KeyPageOperation_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof(KeyPageOperation)) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error KeyPageOperation_set(Bytes *v, KeyPageOperation n) {
    Error e = KeyPageOperation_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error KeyPageOperation_get(const Bytes *v, KeyPageOperation *n) {
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *(KeyPageOperation*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the Key PageOpe ration
ACME_API uint64_t KeyPageOperation_ID(KeyPageOperation v) { return (uint64_t)(v); }

// String returns the name of the Key PageOpe ration
static enum_t KeyPageOperation_l[] = {
	{ "unknown", KeyPageOperationUnknown },
	{ "update", KeyPageOperationUpdate },
	{ "remove", KeyPageOperationRemove },
	{ "add", KeyPageOperationAdd },
	{ "setThreshold", KeyPageOperationSetThreshold },
};

ACME_API Error KeyPageOperation_asString(const Bytes *v, String *out) {
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    KeyPageOperation val = *(KeyPageOperation*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof(KeyPageOperation_l); ++i ) {
        if ( KeyPageOperation_l[i].e == val ) {
            out->set(&out->data, KeyPageOperation_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// KeyPageOperationByName returns the named Key PageOpe ration.
ACME_API Error KeyPageOperation_fromString(Bytes *v, String *name) {
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof(KeyPageOperation_l); ++i ) {
        if ( strncmp(KeyPageOperation_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *(KeyPageOperation*)(v->buffer.ptr + v->buffer.offset) = KeyPageOperation_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// KeyPageOperation_marshalJSON marshals the Key PageOpe ration to JSON as a string.
ACME_API Error KeyPageOperation_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = KeyPageOperation_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// KeyPageOperation_unmarshalJSON unmarshals the Key PageOpe ration from JSON as a string.
ACME_API Error KeyPageOperation_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return KeyPageOperation_fromString(v, &s);
}

// MarshalBinary marshals the Key PageOpe ration to bytes as a unsigned varint.
ACME_API Error KeyPageOperation_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    KeyPageOperation n;
    e = KeyPageOperation_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the Key PageOpe ration from bytes as a unsigned varint.
ACME_API Error KeyPageOperation_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = KeyPageOperation_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	KeyPageOperation_set(v,(KeyPageOperation)t);
	return ErrorCode[ErrorNone];
}

// KeyPageOperation_binarySize returns the number of bytes required to binary marshal the Key PageOpe ration.
KeyPageOperation_t KeyPageOperation_init(KeyPageOperation_t *v, buffer_t *buffer) {
    KeyPageOperation_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    KeyPageOperation_marshalBinary,
                    KeyPageOperation_unmarshalBinary,
                    KeyPageOperation_marshalJSON,
                    KeyPageOperation_unmarshalJSON},
                    KeyPageOperation_get,
                    KeyPageOperation_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof(KeyPageOperation);
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, ObjectType *out);
    Error (*set)(struct Bytes *, ObjectType in);
} ObjectType_t;

ACME_API Error ObjectType_valid(const Bytes *v);
ACME_API Error ObjectType_set(Bytes *v, ObjectType n);
ACME_API Error ObjectType_get(const Bytes *v, ObjectType *n);
ACME_API uint64_t ObjectType_ID(ObjectType v);
ACME_API Error ObjectType_fromString(Bytes *v, String *name);
ACME_API Error ObjectType_asString(const Bytes *v, String *out);
ACME_API Error ObjectType_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error ObjectType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error ObjectType_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error ObjectType_unmarshalBinary(Bytes *v, const Marshaler *in);
ObjectType_t ObjectType_init(ObjectType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error ObjectType_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof(ObjectType)) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error ObjectType_set(Bytes *v, ObjectType n) {
    Error e = ObjectType_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error ObjectType_get(const Bytes *v, ObjectType *n) {
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *(ObjectType*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the Object Type
ACME_API uint64_t ObjectType_ID(ObjectType v) { return (uint64_t)(v); }

// String returns the name of the Object Type
static enum_t ObjectType_l[] = {
	{ "unknown", ObjectTypeUnknown },
	{ "account", ObjectTypeAccount },
	{ "transaction", ObjectTypeTransaction },
};

ACME_API Error ObjectType_asString(const Bytes *v, String *out) {
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    ObjectType val = *(ObjectType*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof(ObjectType_l); ++i ) {
        if ( ObjectType_l[i].e == val ) {
            out->set(&out->data, ObjectType_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// ObjectTypeByName returns the named Object Type.
ACME_API Error ObjectType_fromString(Bytes *v, String *name) {
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof(ObjectType_l); ++i ) {
        if ( strncmp(ObjectType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *(ObjectType*)(v->buffer.ptr + v->buffer.offset) = ObjectType_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// ObjectType_marshalJSON marshals the Object Type to JSON as a string.
ACME_API Error ObjectType_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = ObjectType_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// ObjectType_unmarshalJSON unmarshals the Object Type from JSON as a string.
ACME_API Error ObjectType_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return ObjectType_fromString(v, &s);
}

// MarshalBinary marshals the Object Type to bytes as a unsigned varint.
ACME_API Error ObjectType_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    ObjectType n;
    e = ObjectType_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the Object Type from bytes as a unsigned varint.
ACME_API Error ObjectType_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = ObjectType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	ObjectType_set(v,(ObjectType)t);
	return ErrorCode[ErrorNone];
}

// ObjectType_binarySize returns the number of bytes required to binary marshal the Object Type.
ObjectType_t ObjectType_init(ObjectType_t *v, buffer_t *buffer) {
    ObjectType_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    ObjectType_marshalBinary,
                    ObjectType_unmarshalBinary,
                    ObjectType_marshalJSON,
                    ObjectType_unmarshalJSON},
                    ObjectType_get,
                    ObjectType_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof(ObjectType);
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, TransactionMax *out);
    Error (*set)(struct Bytes *, TransactionMax in);
} TransactionMax_t;

ACME_API Error TransactionMax_valid(const Bytes *v);
ACME_API Error TransactionMax_set(Bytes *v, TransactionMax n);
ACME_API Error TransactionMax_get(const Bytes *v, TransactionMax *n);
ACME_API uint64_t TransactionMax_ID(TransactionMax v);
ACME_API Error TransactionMax_fromString(Bytes *v, String *name);
ACME_API Error TransactionMax_asString(const Bytes *v, String *out);
ACME_API Error TransactionMax_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error TransactionMax_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error TransactionMax_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error TransactionMax_unmarshalBinary(Bytes *v, const Marshaler *in);
TransactionMax_t TransactionMax_init(TransactionMax_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error TransactionMax_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof(TransactionMax)) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error TransactionMax_set(Bytes *v, TransactionMax n) {
    Error e = TransactionMax_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error TransactionMax_get(const Bytes *v, TransactionMax *n) {
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *(TransactionMax*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the Transaction Max
ACME_API uint64_t TransactionMax_ID(TransactionMax v) { return (uint64_t)(v); }

// String returns the name of the Transaction Max
static enum_t TransactionMax_l[] = {
	{ "user", TransactionMaxUser },
	{ "synthetic", TransactionMaxSynthetic },
	{ "internal", TransactionMaxInternal },
};

ACME_API Error TransactionMax_asString(const Bytes *v, String *out) {
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    TransactionMax val = *(TransactionMax*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof(TransactionMax_l); ++i ) {
        if ( TransactionMax_l[i].e == val ) {
            out->set(&out->data, TransactionMax_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// TransactionMaxByName returns the named Transaction Max.
ACME_API Error TransactionMax_fromString(Bytes *v, String *name) {
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof(TransactionMax_l); ++i ) {
        if ( strncmp(TransactionMax_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *(TransactionMax*)(v->buffer.ptr + v->buffer.offset) = TransactionMax_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// TransactionMax_marshalJSON marshals the Transaction Max to JSON as a string.
ACME_API Error TransactionMax_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = TransactionMax_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// TransactionMax_unmarshalJSON unmarshals the Transaction Max from JSON as a string.
ACME_API Error TransactionMax_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return TransactionMax_fromString(v, &s);
}

// MarshalBinary marshals the Transaction Max to bytes as a unsigned varint.
ACME_API Error TransactionMax_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    TransactionMax n;
    e = TransactionMax_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the Transaction Max from bytes as a unsigned varint.
ACME_API Error TransactionMax_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionMax_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	TransactionMax_set(v,(TransactionMax)t);
	return ErrorCode[ErrorNone];
}

// TransactionMax_binarySize returns the number of bytes required to binary marshal the Transaction Max.
TransactionMax_t TransactionMax_init(TransactionMax_t *v, buffer_t *buffer) {
    TransactionMax_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    TransactionMax_marshalBinary,
                    TransactionMax_unmarshalBinary,
                    TransactionMax_marshalJSON,
                    TransactionMax_unmarshalJSON},
                    TransactionMax_get,
                    TransactionMax_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof(TransactionMax);
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, TransactionType *out);
    Error (*set)(struct Bytes *, TransactionType in);
} TransactionType_t;

ACME_API Error TransactionType_valid(const Bytes *v);
ACME_API Error TransactionType_set(Bytes *v, TransactionType n);
ACME_API Error TransactionType_get(const Bytes *v, TransactionType *n);
ACME_API uint64_t TransactionType_ID(TransactionType v);
ACME_API Error TransactionType_fromString(Bytes *v, String *name);
ACME_API Error TransactionType_asString(const Bytes *v, String *out);
ACME_API Error TransactionType_marshalJSON(const Bytes *v, Marshaler *out);
ACME_API Error TransactionType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API Error TransactionType_marshalBinary(const Bytes *v, Marshaler *out);
ACME_API Error TransactionType_unmarshalBinary(Bytes *v, const Marshaler *in);
TransactionType_t TransactionType_init(TransactionType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER

ACME_API Error TransactionType_valid(const Bytes *v) {
    if (!v) {
        return ErrorCode[ErrorParameterNil];
    }
    if (v->buffer.size != sizeof(TransactionType)) {
        return ErrorCode[ErrorBufferTooSmall];
    }
    return ErrorCode[ErrorNone];
}

ACME_API Error TransactionType_set(Bytes *v, TransactionType n) {
    Error e = TransactionType_valid(v);
    if ( e.code != ErrorNone ) {
        return e;
    }

    *(uint64_t*)(v->buffer.ptr+v->buffer.offset) = n;
    return ErrorCode[ErrorNone];
}

ACME_API Error TransactionType_get(const Bytes *v, TransactionType *n) {
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if (!n) {
        return ErrorCode[ErrorParameterNil];
    }

    *n = *(TransactionType*)(v->buffer.ptr+v->buffer.offset);
    return ErrorCode[ErrorNone];
}


// ID returns the ID of the Transaction Type
ACME_API uint64_t TransactionType_ID(TransactionType v) { return (uint64_t)(v); }

// String returns the name of the Transaction Type
static enum_t TransactionType_l[] = {
	{ "unknown", TransactionTypeUnknown },
	{ "createIdentity", TransactionTypeCreateIdentity },
	{ "createTokenAccount", TransactionTypeCreateTokenAccount },
	{ "sendTokens", TransactionTypeSendTokens },
	{ "createDataAccount", TransactionTypeCreateDataAccount },
	{ "writeData", TransactionTypeWriteData },
	{ "writeDataTo", TransactionTypeWriteDataTo },
	{ "acmeFaucet", TransactionTypeAcmeFaucet },
	{ "createToken", TransactionTypeCreateToken },
	{ "issueTokens", TransactionTypeIssueTokens },
	{ "burnTokens", TransactionTypeBurnTokens },
	{ "createKeyPage", TransactionTypeCreateKeyPage },
	{ "createKeyBook", TransactionTypeCreateKeyBook },
	{ "addCredits", TransactionTypeAddCredits },
	{ "updateKeyPage", TransactionTypeUpdateKeyPage },
	{ "signPending", TransactionTypeSignPending },
	{ "syntheticCreateChain", TransactionTypeSyntheticCreateChain },
	{ "syntheticWriteData", TransactionTypeSyntheticWriteData },
	{ "syntheticDepositTokens", TransactionTypeSyntheticDepositTokens },
	{ "syntheticAnchor", TransactionTypeSyntheticAnchor },
	{ "syntheticDepositCredits", TransactionTypeSyntheticDepositCredits },
	{ "syntheticBurnTokens", TransactionTypeSyntheticBurnTokens },
	{ "syntheticMirror", TransactionTypeSyntheticMirror },
	{ "segWitDataEntry", TransactionTypeSegWitDataEntry },
	{ "internalGenesis", TransactionTypeInternalGenesis },
	{ "internalSendTransactions", TransactionTypeInternalSendTransactions },
	{ "internalTransactionsSigned", TransactionTypeInternalTransactionsSigned },
	{ "internalTransactionsSent", TransactionTypeInternalTransactionsSent },
};

ACME_API Error TransactionType_asString(const Bytes *v, String *out) {
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    TransactionType val = *(TransactionType*)(v->buffer.ptr + v->buffer.offset);
    for ( int i = 0; i < sizeof(TransactionType_l); ++i ) {
        if ( TransactionType_l[i].e == val ) {
            out->set(&out->data, TransactionType_l[i].name);
            return ErrorCode[ErrorNone];
        }
    }
    return ErrorCode[ErrorTypeNotFound];
}

// TransactionTypeByName returns the named Transaction Type.
ACME_API Error TransactionType_fromString(Bytes *v, String *name) {
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( int i = 0; i < sizeof(TransactionType_l); ++i ) {
        if ( strncmp(TransactionType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *(TransactionType*)(v->buffer.ptr + v->buffer.offset) = TransactionType_l[i].e;
            return e;
        }
    }
    e.code = ErrorTypeNotFound;
    return e;
}

// TransactionType_marshalJSON marshals the Transaction Type to JSON as a string.
ACME_API Error TransactionType_marshalJSON(const Bytes *v, Marshaler *out) {
    if (!v || !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    e = TransactionType_asString(v, &s);
    if ( e.code != ErrorNone ) {
        return e;
    }
    return s.data.MarshalJSON(&s.data, out);
}

// TransactionType_unmarshalJSON unmarshals the Transaction Type from JSON as a string.
ACME_API Error TransactionType_unmarshalJSON(Bytes *v, const Marshaler *in) {
    if (!v || !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }
    uint8_t data[32] = {0};
    buffer_t buffer = {data, sizeof(data), 0};
    String s = String_init(0, &buffer, sizeof(data));
    //unmarshal the "in" buffer from the Marshaler into a String
    e = s.data.UnmarshalJSON(&s.data, in);
    if ( e.code != ErrorNone ) {
        return e;
    }
    //now convert the unmarshaled string into the enum
    return TransactionType_fromString(v, &s);
}

// MarshalBinary marshals the Transaction Type to bytes as a unsigned varint.
ACME_API Error TransactionType_marshalBinary(const Bytes *v, Marshaler *out) {
    if ( !out ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    if ( !buffer_can_read(&out->cache, VarInt_binarySize(v)) ) {
        return ErrorCode[ErrorParameterInsufficientData];
    }
    TransactionType n;
    e = TransactionType_get(v, &n);
    if ( e.code != ErrorNone ) {
        return e;
    }

    int r = varint_write((uint8_t*)out->cache.ptr,out->cache.offset, (uint64_t)n);
    out->cache.offset += r;
    out->data.buffer.size += r;
    if ( r < 0 ) {
        return ErrorCode[ErrorVarIntWrite];
    }
    return ErrorCode[ErrorNone];
}

// UnmarshalBinary unmarshals the Transaction Type from bytes as a unsigned varint.
ACME_API Error TransactionType_unmarshalBinary(Bytes *v, const Marshaler *in) {
    if ( !in ) {
        return ErrorCode[ErrorParameterNil];
    }
    Error e = TransactionType_valid(v);
    if (e.code != ErrorNone) {
        return e;
    }

    uint64_t t = 0;
    int r = varint_read((uint8_t*)in->data.buffer.ptr+in->data.buffer.offset, in->data.buffer.size,&t);
	if ( r < 0 ) {
		return ErrorCode[ErrorVarIntRead];
	}
	TransactionType_set(v,(TransactionType)t);
	return ErrorCode[ErrorNone];
}

// TransactionType_binarySize returns the number of bytes required to binary marshal the Transaction Type.
TransactionType_t TransactionType_init(TransactionType_t *v, buffer_t *buffer) {
    TransactionType_t init = { { {0,0,0},
                    VarInt_binarySize,
                    Bytes_equal,
                    Bytes_copy,
                    TransactionType_marshalBinary,
                    TransactionType_unmarshalBinary,
                    TransactionType_marshalJSON,
                    TransactionType_unmarshalJSON},
                    TransactionType_get,
                    TransactionType_set,
                  };
    if (buffer) {
        int sizeNeeded = sizeof(TransactionType);
        if ( buffer->size - buffer->offset < sizeNeeded ) {
            return init;
        }
        init.data.buffer.ptr = buffer->ptr;
        init.data.buffer.offset = buffer->offset;
        init.data.buffer.size = sizeNeeded;
        buffer->offset += sizeNeeded;
    }

    if (v) {
        *v = init;
    }
    return init;
}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif


