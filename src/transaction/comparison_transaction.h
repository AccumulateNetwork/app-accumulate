#pragma once


/// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.

#include <common/encoding/encoding.h>
#include <common/protocol/enum.h>
#include <common/protocol/unions.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif

#define _WANT_AcmeFaucet_    1
#define _WANT_AddCredits_    1
#define _WANT_BurnTokens_    1
#define _WANT_CreateDataAccount_    1
#define _WANT_CreateIdentity_    1
#define _WANT_CreateKeyBook_    1
#define _WANT_CreateKeyPage_    1
#define _WANT_CreateLiteTokenAccount_    1
#define _WANT_CreateToken_    1
#define _WANT_CreateTokenAccount_    1
#define _WANT_Envelope_    1
#define _WANT_IssueTokens_    1
#define _WANT_LockAccount_    1
#define _WANT_RemoteTransaction_    1
#define _WANT_SendTokens_    1
#define _WANT_Transaction_    1
#define _WANT_TransactionHeader_    1
#define _WANT_TransactionStatus_    1
#define _WANT_UpdateAccountAuth_    1
#define _WANT_UpdateKey_    1
#define _WANT_UpdateKeyPage_    1
#define _WANT_WriteData_    1
#define _WANT_WriteDataTo_    1

/// Forward Declarations

struct AcmeFaucet;

struct AddCredits;

struct BurnTokens;

struct CreateDataAccount;

struct CreateIdentity;

struct CreateKeyBook;

struct CreateKeyPage;

struct CreateLiteTokenAccount;

struct CreateToken;

struct CreateTokenAccount;

struct Envelope;

struct IssueTokens;

struct LockAccount;

struct RemoteTransaction;

struct SendTokens;

struct Transaction;

struct TransactionHeader;

struct TransactionStatus;

struct UpdateAccountAuth;

struct UpdateKey;

struct UpdateKeyPage;

struct WriteData;

struct WriteDataTo;


/// Data Structures

#if _WANT_AcmeFaucet_
typedef struct AcmeFaucet {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	//Bytes extraData[2];

} AcmeFaucet;
#endif /* _WANT_AcmeFaucet_ */

#if _WANT_AddCredits_
typedef struct AddCredits {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[4];
	Url Recipient;  //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	BigInt Amount;  //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	UVarInt Oracle;  //`json:"oracle,omitempty" form:"oracle" query:"oracle"`
	//Bytes extraData[4];

} AddCredits;
#endif /* _WANT_AddCredits_ */

#if _WANT_BurnTokens_
typedef struct BurnTokens {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
	BigInt Amount;  //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	//Bytes extraData[2];

} BurnTokens;
#endif /* _WANT_BurnTokens_ */

#if _WANT_CreateDataAccount_
typedef struct CreateDataAccount {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[3];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	/// Authorities is a list of authorities to add to the authority set.
        size_t Authorities_length;
	Url* Authorities;  //`json:"authorities,omitempty" form:"authorities" query:"authorities"`
	//Bytes extraData[3];

} CreateDataAccount;
#endif /* _WANT_CreateDataAccount_ */

#if _WANT_CreateIdentity_
typedef struct CreateIdentity {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[5];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Bytes KeyHash;  //`json:"keyHash,omitempty" form:"keyHash" query:"keyHash"`
	/// KeyBookUrl creates a new key book.
	Url KeyBookUrl;  //`json:"keyBookUrl,omitempty" form:"keyBookUrl" query:"keyBookUrl"`
	/// Authorities is a list of authorities to add to the authority set, in addition to the new key book.
        size_t Authorities_length;
	Url* Authorities;  //`json:"authorities,omitempty" form:"authorities" query:"authorities"`
	//Bytes extraData[5];

} CreateIdentity;
#endif /* _WANT_CreateIdentity_ */

#if _WANT_CreateKeyBook_
typedef struct CreateKeyBook {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[4];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Bytes PublicKeyHash;  //`json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	/// Authorities is a list of authorities to add to the authority set, in addition to the key book itself.
        size_t Authorities_length;
	Url* Authorities;  //`json:"authorities,omitempty" form:"authorities" query:"authorities"`
	//Bytes extraData[4];

} CreateKeyBook;
#endif /* _WANT_CreateKeyBook_ */

#if _WANT_CreateKeyPage_
typedef struct CreateKeyPage {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
        size_t Keys_length;
	KeySpecParams* Keys;  //`json:"keys,omitempty" form:"keys" query:"keys" validate:"required"`
	//Bytes extraData[2];

} CreateKeyPage;
#endif /* _WANT_CreateKeyPage_ */

#if _WANT_CreateLiteTokenAccount_
typedef struct CreateLiteTokenAccount {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[1];
	//Bytes extraData[1];

} CreateLiteTokenAccount;
#endif /* _WANT_CreateLiteTokenAccount_ */

#if _WANT_CreateToken_
typedef struct CreateToken {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[7];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	String Symbol;  //`json:"symbol,omitempty" form:"symbol" query:"symbol" validate:"required"`
	UVarInt Precision;  //`json:"precision,omitempty" form:"precision" query:"precision" validate:"required"`
	Url Properties;  //`json:"properties,omitempty" form:"properties" query:"properties"`
	BigInt SupplyLimit;  //`json:"supplyLimit,omitempty" form:"supplyLimit" query:"supplyLimit"`
	/// Authorities is a list of authorities to add to the authority set.
        size_t Authorities_length;
	Url* Authorities;  //`json:"authorities,omitempty" form:"authorities" query:"authorities"`
	//Bytes extraData[7];

} CreateToken;
#endif /* _WANT_CreateToken_ */

#if _WANT_CreateTokenAccount_
typedef struct CreateTokenAccount {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[5];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	Url TokenUrl;  //`json:"tokenUrl,omitempty" form:"tokenUrl" query:"tokenUrl" validate:"required"`
	/// Authorities is a list of authorities to add to the authority set.
        size_t Authorities_length;
	Url* Authorities;  //`json:"authorities,omitempty" form:"authorities" query:"authorities"`
	TokenIssuerProof Proof;  //`json:"proof,omitempty" form:"proof" query:"proof"`
	//Bytes extraData[5];

} CreateTokenAccount;
#endif /* _WANT_CreateTokenAccount_ */

#if _WANT_Envelope_
typedef struct Envelope {
    
    //

	//uint8_t fieldsSet[3];
        size_t Signatures_length;
	Signature* Signatures;  //`json:"signatures,omitempty" form:"signatures" query:"signatures" validate:"required"`
	Bytes TxHash;  //`json:"txHash,omitempty" form:"txHash" query:"txHash"`
        size_t Transaction_length;
	Transaction* Transaction;  //`json:"transaction,omitempty" form:"transaction" query:"transaction"`
	//Bytes extraData[3];

} Envelope;
#endif /* _WANT_Envelope_ */

#if _WANT_IssueTokens_
typedef struct IssueTokens {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[4];
	Url Recipient;  //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	BigInt Amount;  //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
        size_t To_length;
	TokenRecipient* To;  //`json:"to,omitempty" form:"to" query:"to" validate:"required"`
	//Bytes extraData[4];

} IssueTokens;
#endif /* _WANT_IssueTokens_ */

#if _WANT_LockAccount_
typedef struct LockAccount {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
	/// Height is the major block height when the account will be released.
	UVarInt Height;  //`json:"height,omitempty" form:"height" query:"height" validate:"required"`
	//Bytes extraData[2];

} LockAccount;
#endif /* _WANT_LockAccount_ */

#if _WANT_RemoteTransaction_
typedef struct RemoteTransaction {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
	Bytes32 Hash;  //`json:"hash,omitempty" form:"hash" query:"hash"`
	//Bytes extraData[2];

} RemoteTransaction;
#endif /* _WANT_RemoteTransaction_ */

#if _WANT_SendTokens_
typedef struct SendTokens {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[4];
	Bytes32 Hash;  //`json:"hash,omitempty" form:"hash" query:"hash"`
	RawJson Meta;  //`json:"meta,omitempty" form:"meta" query:"meta"`
        size_t To_length;
	TokenRecipient* To;  //`json:"to,omitempty" form:"to" query:"to" validate:"required"`
	//Bytes extraData[4];

} SendTokens;
#endif /* _WANT_SendTokens_ */

#if _WANT_Transaction_
typedef struct Transaction {
    
    //

	//uint8_t fieldsSet[3];
	TransactionHeader Header;  //`json:"header,omitempty" form:"header" query:"header" validate:"required"`
	TransactionBody Body;  //`json:"body,omitempty" form:"body" query:"body" validate:"required"`
	Bytes hash; 
	//Bytes extraData[3];

} Transaction;
#endif /* _WANT_Transaction_ */

#if _WANT_TransactionHeader_
typedef struct TransactionHeader {
    
    //

	//uint8_t fieldsSet[4];
	Url Principal;  //`json:"principal,omitempty" form:"principal" query:"principal" validate:"required"`
	Bytes32 Initiator;  //`json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	String Memo;  //`json:"memo,omitempty" form:"memo" query:"memo"`
	Bytes Metadata;  //`json:"metadata,omitempty" form:"metadata" query:"metadata"`
	//Bytes extraData[4];

} TransactionHeader;
#endif /* _WANT_TransactionHeader_ */

#if _WANT_TransactionStatus_
typedef struct TransactionStatus {
    
    //

	//uint8_t fieldsSet[18];
	Bytes32 TxID;  //`json:"txID,omitempty" form:"txID" query:"txID" validate:"required"`
	Status Code;  //`json:"code,omitempty" form:"code" query:"code" validate:"required"`
	Error Error;  //`json:"error,omitempty" form:"error" query:"error" validate:"required"`
	TransactionResult Result;  //`json:"result,omitempty" form:"result" query:"result" validate:"required"`
	/// Received is the block when the transaction was first received.
	UVarInt Received;  //`json:"received,omitempty" form:"received" query:"received" validate:"required"`
	/// Initiator is the signer that initiated the transaction.
	Url Initiator;  //`json:"initiator,omitempty" form:"initiator" query:"initiator" validate:"required"`
	/// Signers lists accounts that have signed the transaction.
        size_t Signers_length;
	Signer* Signers;  //`json:"signers,omitempty" form:"signers" query:"signers" validate:"required"`
	/// SourceNetwork is the network that produced the transaction.
	Url SourceNetwork;  //`json:"sourceNetwork,omitempty" form:"sourceNetwork" query:"sourceNetwork" validate:"required"`
	/// DestinationNetwork is the network that the transaction is sent to.
	Url DestinationNetwork;  //`json:"destinationNetwork,omitempty" form:"destinationNetwork" query:"destinationNetwork" validate:"required"`
	/// SequenceNumber is the sequence number of the transaction.
	UVarInt SequenceNumber;  //`json:"sequenceNumber,omitempty" form:"sequenceNumber" query:"sequenceNumber" validate:"required"`
	/// GotDirectoryReceipt indicates if a receipt has been received from the DN.
	Bool GotDirectoryReceipt;  //`json:"gotDirectoryReceipt,omitempty" form:"gotDirectoryReceipt" query:"gotDirectoryReceipt" validate:"required"`
	/// Proof is the proof of the transaction.
	Receipt Proof;  //`json:"proof,omitempty" form:"proof" query:"proof" validate:"required"`
	/// AnchorSigners is the list of validators that have signed the anchor.
        size_t AnchorSigners_length;
	Bytes* AnchorSigners;  //`json:"anchorSigners,omitempty" form:"anchorSigners" query:"anchorSigners" validate:"required"`
	//Bytes extraData[18];

} TransactionStatus;
#endif /* _WANT_TransactionStatus_ */

#if _WANT_UpdateAccountAuth_
typedef struct UpdateAccountAuth {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
        size_t Operations_length;
	AccountAuthOperation* Operations;  //`json:"operations,omitempty" form:"operations" query:"operations" validate:"required"`
	//Bytes extraData[2];

} UpdateAccountAuth;
#endif /* _WANT_UpdateAccountAuth_ */

#if _WANT_UpdateKey_
typedef struct UpdateKey {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
	Bytes NewKeyHash;  //`json:"newKeyHash,omitempty" form:"newKeyHash" query:"newKeyHash" validate:"required"`
	//Bytes extraData[2];

} UpdateKey;
#endif /* _WANT_UpdateKey_ */

#if _WANT_UpdateKeyPage_
typedef struct UpdateKeyPage {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[2];
        size_t Operation_length;
	KeyPageOperation* Operation;  //`json:"operation,omitempty" form:"operation" query:"operation" validate:"required"`
	//Bytes extraData[2];

} UpdateKeyPage;
#endif /* _WANT_UpdateKeyPage_ */

#if _WANT_WriteData_
typedef struct WriteData {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[4];
	DataEntry Entry;  //`json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	Bool Scratch;  //`json:"scratch,omitempty" form:"scratch" query:"scratch"`
	/// WriteToState writes the data entry to the account state.
	Bool WriteToState;  //`json:"writeToState,omitempty" form:"writeToState" query:"writeToState"`
	//Bytes extraData[4];

} WriteData;
#endif /* _WANT_WriteData_ */

#if _WANT_WriteDataTo_
typedef struct WriteDataTo {
    
    TransactionType Type;
    
    //

	//uint8_t fieldsSet[3];
	Url Recipient;  //`json:"recipient,omitempty" form:"recipient" query:"recipient" validate:"required"`
	DataEntry Entry;  //`json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	//Bytes extraData[3];

} WriteDataTo;
#endif /* _WANT_WriteDataTo_ */





#if _WANT_AcmeFaucet_
ACME_API int readAcmeFaucet(Unmarshaler *m, AcmeFaucet *v);

#endif /* _WANT_AcmeFaucet_ */

#if _WANT_AddCredits_
ACME_API int readAddCredits(Unmarshaler *m, AddCredits *v);

#endif /* _WANT_AddCredits_ */

#if _WANT_BurnTokens_
ACME_API int readBurnTokens(Unmarshaler *m, BurnTokens *v);

#endif /* _WANT_BurnTokens_ */

#if _WANT_CreateDataAccount_
ACME_API int readCreateDataAccount(Unmarshaler *m, CreateDataAccount *v);

#endif /* _WANT_CreateDataAccount_ */

#if _WANT_CreateIdentity_
ACME_API int readCreateIdentity(Unmarshaler *m, CreateIdentity *v);

#endif /* _WANT_CreateIdentity_ */

#if _WANT_CreateKeyBook_
ACME_API int readCreateKeyBook(Unmarshaler *m, CreateKeyBook *v);

#endif /* _WANT_CreateKeyBook_ */

#if _WANT_CreateKeyPage_
ACME_API int readCreateKeyPage(Unmarshaler *m, CreateKeyPage *v);

#endif /* _WANT_CreateKeyPage_ */

#if _WANT_CreateLiteTokenAccount_
ACME_API int readCreateLiteTokenAccount(Unmarshaler *m, CreateLiteTokenAccount *v);

#endif /* _WANT_CreateLiteTokenAccount_ */

#if _WANT_CreateToken_
ACME_API int readCreateToken(Unmarshaler *m, CreateToken *v);

#endif /* _WANT_CreateToken_ */

#if _WANT_CreateTokenAccount_
ACME_API int readCreateTokenAccount(Unmarshaler *m, CreateTokenAccount *v);

#endif /* _WANT_CreateTokenAccount_ */

#if _WANT_Envelope_
ACME_API int readEnvelope(Unmarshaler *m, Envelope *v);

#endif /* _WANT_Envelope_ */

#if _WANT_IssueTokens_
ACME_API int readIssueTokens(Unmarshaler *m, IssueTokens *v);

#endif /* _WANT_IssueTokens_ */

#if _WANT_LockAccount_
ACME_API int readLockAccount(Unmarshaler *m, LockAccount *v);

#endif /* _WANT_LockAccount_ */

#if _WANT_RemoteTransaction_
ACME_API int readRemoteTransaction(Unmarshaler *m, RemoteTransaction *v);

#endif /* _WANT_RemoteTransaction_ */

#if _WANT_SendTokens_
ACME_API int readSendTokens(Unmarshaler *m, SendTokens *v);

#endif /* _WANT_SendTokens_ */

#if _WANT_Transaction_
ACME_API int readTransaction(Unmarshaler *m, Transaction *v);

#endif /* _WANT_Transaction_ */

#if _WANT_TransactionHeader_
ACME_API int readTransactionHeader(Unmarshaler *m, TransactionHeader *v);

#endif /* _WANT_TransactionHeader_ */

#if _WANT_TransactionStatus_
ACME_API int readTransactionStatus(Unmarshaler *m, TransactionStatus *v);

#endif /* _WANT_TransactionStatus_ */

#if _WANT_UpdateAccountAuth_
ACME_API int readUpdateAccountAuth(Unmarshaler *m, UpdateAccountAuth *v);

#endif /* _WANT_UpdateAccountAuth_ */

#if _WANT_UpdateKey_
ACME_API int readUpdateKey(Unmarshaler *m, UpdateKey *v);

#endif /* _WANT_UpdateKey_ */

#if _WANT_UpdateKeyPage_
ACME_API int readUpdateKeyPage(Unmarshaler *m, UpdateKeyPage *v);

#endif /* _WANT_UpdateKeyPage_ */

#if _WANT_WriteData_
ACME_API int readWriteData(Unmarshaler *m, WriteData *v);

#endif /* _WANT_WriteData_ */

#if _WANT_WriteDataTo_
ACME_API int readWriteDataTo(Unmarshaler *m, WriteDataTo *v);

#endif /* _WANT_WriteDataTo_ */



#ifdef _ACCUMULATE_TRANSACTION_SOURCE_


#if _WANT_AcmeFaucet_
// UnmarshalBinary unmarshals the acme faucet from bytes as a unsigned varint.
int readAcmeFaucet(Unmarshaler *m, AcmeFaucet *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeAcmeFaucet;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Url);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_AcmeFaucet_ */

#if _WANT_AddCredits_
// UnmarshalBinary unmarshals the add credits from bytes as a unsigned varint.
int readAddCredits(Unmarshaler *m, AddCredits *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeAddCredits;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Recipient);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBigInt(m, &v->Amount);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUVarInt(m, &v->Oracle);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_AddCredits_ */

#if _WANT_BurnTokens_
// UnmarshalBinary unmarshals the burn tokens from bytes as a unsigned varint.
int readBurnTokens(Unmarshaler *m, BurnTokens *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeBurnTokens;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBigInt(m, &v->Amount);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_BurnTokens_ */

#if _WANT_CreateDataAccount_
// UnmarshalBinary unmarshals the create data account from bytes as a unsigned varint.
int readCreateDataAccount(Unmarshaler *m, CreateDataAccount *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateDataAccount;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Url);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Authorities_length = 0;
        while (field == 3) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            //need to read the known type
            {
                Url a;
                b = readUrl(&m2, &a);
                CHECK_ERROR_CODE(b);
            }

            v->Authorities_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Authorities = (Url *) unmarshalerAlloc(m, v->Authorities_length * sizeof(Url));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Authorities_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 3) {
                return ErrorInvalidField;
            }
            b = unmarshalerReadUrl(m, &v->Authorities[i]);
            CHECK_ERROR_CODE(b);

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_CreateDataAccount_ */

#if _WANT_CreateIdentity_
// UnmarshalBinary unmarshals the create identity from bytes as a unsigned varint.
int readCreateIdentity(Unmarshaler *m, CreateIdentity *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateIdentity;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Url);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes(m, &v->KeyHash);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->KeyBookUrl);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 6) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Authorities_length = 0;
        while (field == 6) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            //need to read the known type
            {
                Url a;
                b = readUrl(&m2, &a);
                CHECK_ERROR_CODE(b);
            }

            v->Authorities_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Authorities = (Url *) unmarshalerAlloc(m, v->Authorities_length * sizeof(Url));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Authorities_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 6) {
                return ErrorInvalidField;
            }
            b = unmarshalerReadUrl(m, &v->Authorities[i]);
            CHECK_ERROR_CODE(b);

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_CreateIdentity_ */

#if _WANT_CreateKeyBook_
// UnmarshalBinary unmarshals the create key book from bytes as a unsigned varint.
int readCreateKeyBook(Unmarshaler *m, CreateKeyBook *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateKeyBook;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Url);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes(m, &v->PublicKeyHash);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 5) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Authorities_length = 0;
        while (field == 5) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            //need to read the known type
            {
                Url a;
                b = readUrl(&m2, &a);
                CHECK_ERROR_CODE(b);
            }

            v->Authorities_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Authorities = (Url *) unmarshalerAlloc(m, v->Authorities_length * sizeof(Url));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Authorities_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 5) {
                return ErrorInvalidField;
            }
            b = unmarshalerReadUrl(m, &v->Authorities[i]);
            CHECK_ERROR_CODE(b);

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_CreateKeyBook_ */

#if _WANT_CreateKeyPage_
// UnmarshalBinary unmarshals the create key page from bytes as a unsigned varint.
int readCreateKeyPage(Unmarshaler *m, CreateKeyPage *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateKeyPage;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Keys_length = 0;
        while (field == 2) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Keys_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Keys = (KeySpecParams *) unmarshalerAlloc(m, v->Keys_length * sizeof(KeySpecParams));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Keys_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 2) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readKeySpecParams(&m3, &v->Keys[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_CreateKeyPage_ */

#if _WANT_CreateLiteTokenAccount_
// UnmarshalBinary unmarshals the create lite token account from bytes as a unsigned varint.
int readCreateLiteTokenAccount(Unmarshaler *m, CreateLiteTokenAccount *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateLiteTokenAccount;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_CreateLiteTokenAccount_ */

#if _WANT_CreateToken_
// UnmarshalBinary unmarshals the create token from bytes as a unsigned varint.
int readCreateToken(Unmarshaler *m, CreateToken *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateToken;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Url);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadString(m, &v->Symbol);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 5) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUVarInt(m, &v->Precision);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 6) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Properties);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 7) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBigInt(m, &v->SupplyLimit);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 9) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Authorities_length = 0;
        while (field == 9) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            //need to read the known type
            {
                Url a;
                b = readUrl(&m2, &a);
                CHECK_ERROR_CODE(b);
            }

            v->Authorities_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Authorities = (Url *) unmarshalerAlloc(m, v->Authorities_length * sizeof(Url));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Authorities_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 9) {
                return ErrorInvalidField;
            }
            b = unmarshalerReadUrl(m, &v->Authorities[i]);
            CHECK_ERROR_CODE(b);

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_CreateToken_ */

#if _WANT_CreateTokenAccount_
// UnmarshalBinary unmarshals the create token account from bytes as a unsigned varint.
int readCreateTokenAccount(Unmarshaler *m, CreateTokenAccount *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeCreateTokenAccount;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Url);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->TokenUrl);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 7) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Authorities_length = 0;
        while (field == 7) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            //need to read the known type
            {
                Url a;
                b = readUrl(&m2, &a);
                CHECK_ERROR_CODE(b);
            }

            v->Authorities_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Authorities = (Url *) unmarshalerAlloc(m, v->Authorities_length * sizeof(Url));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Authorities_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 7) {
                return ErrorInvalidField;
            }
            b = unmarshalerReadUrl(m, &v->Authorities[i]);
            CHECK_ERROR_CODE(b);

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 8) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadTokenIssuerProof(&m2, &v->Proof);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_CreateTokenAccount_ */

#if _WANT_Envelope_
// UnmarshalBinary unmarshals the envelope from bytes as a unsigned varint.
int readEnvelope(Unmarshaler *m, Envelope *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Signatures_length = 0;
        while (field == 1) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Signatures_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Signatures = (Signature *) unmarshalerAlloc(m, v->Signatures_length * sizeof(Signature));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Signatures_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 1) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readSignature(&m3, &v->Signatures[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes(m, &v->TxHash);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Transaction_length = 0;
        while (field == 3) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Transaction_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Transaction = (Transaction *) unmarshalerAlloc(m, v->Transaction_length * sizeof(Transaction));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Transaction_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 3) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readTransaction(&m3, &v->Transaction[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_Envelope_ */

#if _WANT_IssueTokens_
// UnmarshalBinary unmarshals the issue tokens from bytes as a unsigned varint.
int readIssueTokens(Unmarshaler *m, IssueTokens *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeIssueTokens;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Recipient);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBigInt(m, &v->Amount);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->To_length = 0;
        while (field == 4) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->To_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->To = (TokenRecipient *) unmarshalerAlloc(m, v->To_length * sizeof(TokenRecipient));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->To_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 4) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readTokenRecipient(&m3, &v->To[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_IssueTokens_ */

#if _WANT_LockAccount_
// UnmarshalBinary unmarshals the lock account from bytes as a unsigned varint.
int readLockAccount(Unmarshaler *m, LockAccount *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeLockAccount;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUVarInt(m, &v->Height);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_LockAccount_ */

#if _WANT_RemoteTransaction_
// UnmarshalBinary unmarshals the remote transaction from bytes as a unsigned varint.
int readRemoteTransaction(Unmarshaler *m, RemoteTransaction *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeRemote;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes32(m, &v->Hash);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_RemoteTransaction_ */

#if _WANT_SendTokens_
// UnmarshalBinary unmarshals the send tokens from bytes as a unsigned varint.
int readSendTokens(Unmarshaler *m, SendTokens *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeSendTokens;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes32(m, &v->Hash);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadRawJson(m, &v->Meta);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->To_length = 0;
        while (field == 4) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->To_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->To = (TokenRecipient *) unmarshalerAlloc(m, v->To_length * sizeof(TokenRecipient));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->To_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 4) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readTokenRecipient(&m3, &v->To[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_SendTokens_ */

#if _WANT_Transaction_
// UnmarshalBinary unmarshals the transaction from bytes as a unsigned varint.
int readTransaction(Unmarshaler *m, Transaction *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadTransactionHeader(&m2, &v->Header);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadTransactionBody(&m2, &v->Body);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_Transaction_ */

#if _WANT_TransactionHeader_
// UnmarshalBinary unmarshals the transaction header from bytes as a unsigned varint.
int readTransactionHeader(Unmarshaler *m, TransactionHeader *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Principal);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes32(m, &v->Initiator);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadString(m, &v->Memo);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes(m, &v->Metadata);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_TransactionHeader_ */

#if _WANT_TransactionStatus_
// UnmarshalBinary unmarshals the transaction status from bytes as a unsigned varint.
int readTransactionStatus(Unmarshaler *m, TransactionStatus *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes32(m, &v->TxID);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadStatus(&m2, &v->Code);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 0) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->Remote);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 0) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->Delivered);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 0) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->Pending);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 0) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->Failed);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 0) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUVarInt(m, &v->CodeNum);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadError(&m2, &v->Error);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadTransactionResult(&m2, &v->Result);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 5) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUVarInt(m, &v->Received);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 6) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Initiator);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 7) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Signers_length = 0;
        while (field == 7) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Signers_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Signers = (Signer *) unmarshalerAlloc(m, v->Signers_length * sizeof(Signer));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Signers_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 7) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readSigner(&m3, &v->Signers[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 8) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->SourceNetwork);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 9) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->DestinationNetwork);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 10) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUVarInt(m, &v->SequenceNumber);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 11) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->GotDirectoryReceipt);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 12) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadReceipt(&m2, &v->Proof);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 13) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->AnchorSigners_length = 0;
        while (field == 13) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            //need to read the known type
            {
                Bytes a;
                b = readBytes(&m2, &a);
                CHECK_ERROR_CODE(b);
            }

            v->AnchorSigners_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->AnchorSigners = (Bytes *) unmarshalerAlloc(m, v->AnchorSigners_length * sizeof(Bytes));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->AnchorSigners_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 13) {
                return ErrorInvalidField;
            }
            b = unmarshalerReadBytes(m, &v->AnchorSigners[i]);
            CHECK_ERROR_CODE(b);

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_TransactionStatus_ */

#if _WANT_UpdateAccountAuth_
// UnmarshalBinary unmarshals the update account auth from bytes as a unsigned varint.
int readUpdateAccountAuth(Unmarshaler *m, UpdateAccountAuth *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeUpdateAccountAuth;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Operations_length = 0;
        while (field == 2) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Operations_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Operations = (AccountAuthOperation *) unmarshalerAlloc(m, v->Operations_length * sizeof(AccountAuthOperation));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Operations_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 2) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readAccountAuthOperation(&m3, &v->Operations[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_UpdateAccountAuth_ */

#if _WANT_UpdateKey_
// UnmarshalBinary unmarshals the update key from bytes as a unsigned varint.
int readUpdateKey(Unmarshaler *m, UpdateKey *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeUpdateKey;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBytes(m, &v->NewKeyHash);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_UpdateKey_ */

#if _WANT_UpdateKeyPage_
// UnmarshalBinary unmarshals the update key page from bytes as a unsigned varint.
int readUpdateKeyPage(Unmarshaler *m, UpdateKeyPage *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeUpdateKeyPage;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,m->mempool);
        v->Operation_length = 0;
        while (field == 2) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            //skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Operation_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        //now unmarshal for real...
        v->Operation = (KeyPageOperation *) unmarshalerAlloc(m, v->Operation_length * sizeof(KeyPageOperation));
        CHECK_ERROR_INT(v->To);
        for (size_t i = 0; i < v->Operation_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 2) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                                  .buffer.size = size,
                                                  .buffer.offset = 0,
                                                  .mempool = m->mempool};
                b = readKeyPageOperation(&m3, &v->Operation[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size; //skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

	return n;
}


#endif /* _WANT_UpdateKeyPage_ */

#if _WANT_WriteData_
// UnmarshalBinary unmarshals the write data from bytes as a unsigned varint.
int readWriteData(Unmarshaler *m, WriteData *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeWriteData;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadDataEntry(&m2, &v->Entry);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->Scratch);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 4) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadBool(m, &v->WriteToState);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_WriteData_ */

#if _WANT_WriteDataTo_
// UnmarshalBinary unmarshals the write data to from bytes as a unsigned varint.
int readWriteDataTo(Unmarshaler *m, WriteDataTo *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    v->Type = TransactionTypeWriteDataTo;
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t type = 0;
        b = unmarshalerReadUInt(m, &type);
        CHECK_ERROR_CODE(b);
        if (type != v->Type) {
            return ErrorInvalidObject;
        }
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        b = unmarshalerReadUrl(m, &v->Recipient);
        CHECK_ERROR_CODE(b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;
        
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        Unmarshaler m2 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset, .buffer.size = size, .buffer.offset = 0,
                          .mempool = m->mempool};
        b = unmarshalerReadDataEntry(&m2, &v->Entry);
        CHECK_ERROR_CODE(b);
        buffer_seek_cur(&m->buffer, b);
        
        n += b;
        v->extraData[field - 1].buffer.size += b;
    }

	return n;
}


#endif /* _WANT_WriteDataTo_ */

#endif /* _ACCUMULATE_TRANSACTION_SOURCE_ */

#ifdef __cplusplus
}
#endif


