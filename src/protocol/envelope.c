/// GENERATED BY go run ./tools/cmd/gentypes. DO NOT EDIT.
#include <protocol/signatures.h>
#include <protocol/transaction.h>
#include <transaction/utils.h>

#if _WANT_Envelope_

int readEnvelope(Unmarshaler *m, Envelope *v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    uint64_t field = 0;

    explicit_bzero(v->extraData, sizeof(v->extraData));

    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 1) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;

        Unmarshaler m2 = NewUnmarshaler(&m->buffer, m->mempool);
        v->Signatures_length = 0;
        while (field == 1) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            // skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Signatures_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        // now unmarshal for real...
        v->Signatures = (Signature *) unmarshalerAlloc(m, v->Signatures_length * sizeof(Signature));
        CHECK_ERROR_INT(v->Signatures);
        for (size_t i = 0; i < v->Signatures_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 1) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                  .buffer.size = size,
                                  .buffer.offset = 0,
                                  .mempool = m->mempool};
                b = readSignature(&m3, &v->Signatures[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size;  // skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 2) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;
        b = unmarshalerReadField(m, &field);
        CHECK_ERROR_CODE(b);
        n += b;
        v->extraData[field - 1].buffer.size += b;

        b = unmarshalerReadBytes(m, &v->TxHash);
        CHECK_ERROR_CODE(b);

        n += b;
        v->extraData[field - 1].buffer.size += b;
    }
    if (m->buffer.offset == m->buffer.size) {
        return n;
    }
    b = unmarshalerPeekField(m, &field);
    CHECK_ERROR_CODE(b);
    if (field == 3) {
        v->extraData[field - 1].buffer.ptr = m->buffer.ptr + m->buffer.offset;

        Unmarshaler m2 = NewUnmarshaler(&m->buffer, m->mempool);
        v->Transaction_length = 0;
        while (field == 3) {
            b = unmarshalerReadField(&m2, &field);
            CHECK_ERROR_CODE(b);
            uint64_t size = 0;
            b = unmarshalerReadUInt(&m2, &size);
            CHECK_ERROR_CODE(b);
            // skip the object
            buffer_seek_cur(&m2.buffer, size);

            v->Transaction_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }

        // now unmarshal for real...
        v->Transaction =
            (Transaction *) unmarshalerAlloc(m, v->Transaction_length * sizeof(Transaction));
        CHECK_ERROR_INT(v->Transaction);
        for (size_t i = 0; i < v->Transaction_length; ++i) {
            b = unmarshalerReadField(m, &field);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            if (field != 3) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m, &size);
            CHECK_ERROR_CODE(b);
            n += b;
            v->extraData[field - 1].buffer.size += b;
            {
                Unmarshaler m3 = {.buffer.ptr = m->buffer.ptr + m->buffer.offset,
                                  .buffer.size = size,
                                  .buffer.offset = 0,
                                  .mempool = m->mempool};
                b = readTransaction(&m3, &v->Transaction[i]);
                CHECK_ERROR_CODE(b);
            }
            buffer_seek_cur(&m->buffer, size);
            b = size;  // skip over any remainder

            n += (int) b;
            v->extraData[field - 1].buffer.size += b;
        }
    }

    return n;
}

#endif /* _WANT_Envelope_ */
