#pragma once

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif
#include <common/encoding/encoding.h>
#include <common/encoding/marshaler.h>

typedef struct {
   const char *name;
   uint32_t e;
} enum_t;



typedef enum {

    // AccountAuthOperationTypeUnknown is used when the authorization operation is not known.
    AccountAuthOperationTypeUnknown = 0,

    // AccountAuthOperationTypeEnable enables authorization checks for an authority.
    AccountAuthOperationTypeEnable = 1,

    // AccountAuthOperationTypeDisable disables authorization checks for an authority.
    AccountAuthOperationTypeDisable = 2,

    // AccountAuthOperationTypeAddAuthority adds an authority.
    AccountAuthOperationTypeAddAuthority = 3,

    // AccountAuthOperationTypeRemoveAuthority removes an authority.
    AccountAuthOperationTypeRemoveAuthority = 4,

} AccountAuthOperationType;


typedef enum {

    // AccountTypeUnknown represents an unknown account type.
    AccountTypeUnknown = 0,

    // AccountTypeAnchorLedger anchors the other partitions.
    AccountTypeAnchorLedger = 1,

    // AccountTypeIdentity is an Identity account, aka an ADI.
    AccountTypeIdentity = 2,

    // AccountTypeTokenIssuer is a Token Issuer account.
    AccountTypeTokenIssuer = 3,

    // AccountTypeTokenAccount is an ADI Token Account.
    AccountTypeTokenAccount = 4,

    // AccountTypeLiteTokenAccount is a Lite Token Account.
    AccountTypeLiteTokenAccount = 5,

    // AccountTypeBlockLedger is a Block Ledger account.
    AccountTypeBlockLedger = 6,

    // AccountTypeKeyPage is a Key Page account.
    AccountTypeKeyPage = 9,

    // AccountTypeKeyBook is a Key Book account.
    AccountTypeKeyBook = 10,

    // AccountTypeDataAccount is an ADI Data Account.
    AccountTypeDataAccount = 11,

    // AccountTypeLiteDataAccount is a Lite Data Account.
    AccountTypeLiteDataAccount = 12,

    // AccountTypeUnknownSigner represents an unknown signer account.
    AccountTypeUnknownSigner = 13,

    // AccountTypeSystemLedger is a ledger that tracks the state of internal operations.
    AccountTypeSystemLedger = 14,

    // AccountTypeLiteIdentity is a lite identity account.
    AccountTypeLiteIdentity = 15,

    // AccountTypeSyntheticLedger is a ledger that tracks the status of produced and received synthetic transactions.
    AccountTypeSyntheticLedger = 16,

} AccountType;


typedef enum {

    // AllowedTransactionBitUpdateKeyPage is the offset of the UpdateKeyPage bit.
    AllowedTransactionBitUpdateKeyPage = 1,

    // AllowedTransactionBitUpdateAccountAuth is the offset of the UpdateAccountAuth bit.
    AllowedTransactionBitUpdateAccountAuth = 2,

} AllowedTransactionBit;


typedef enum {

    // BookTypeNormal is a normal key book.
    BookTypeNormal = 0,

    // BookTypeValidator is a validator key book.
    BookTypeValidator = 1,

    // BookTypeOperator Operator key book.
    BookTypeOperator = 2,

} BookType;


typedef enum {

    // DataEntryTypeUnknown .
    DataEntryTypeUnknown = 0,

    // DataEntryTypeFactom .
    DataEntryTypeFactom = 1,

    // DataEntryTypeAccumulate .
    DataEntryTypeAccumulate = 2,

} DataEntryType;


typedef enum {

    // KeyPageOperationTypeUnknown is used when the key page operation is not known.
    KeyPageOperationTypeUnknown = 0,

    // KeyPageOperationTypeUpdate replaces a key in the page with a new key.
    KeyPageOperationTypeUpdate = 1,

    // KeyPageOperationTypeRemove removes a key from the page.
    KeyPageOperationTypeRemove = 2,

    // KeyPageOperationTypeAdd adds a key to the page.
    KeyPageOperationTypeAdd = 3,

    // KeyPageOperationTypeSetThreshold sets the signing threshold (the M of "M of N" signatures required).
    KeyPageOperationTypeSetThreshold = 4,

    // KeyPageOperationTypeUpdateAllowed updates the transactions the key page is allowed to execute.
    KeyPageOperationTypeUpdateAllowed = 5,

} KeyPageOperationType;


typedef enum {

    // ObjectTypeUnknown is used when the object type is not known.
    ObjectTypeUnknown = 0,

    // ObjectTypeAccount represents an account object.
    ObjectTypeAccount = 1,

    // ObjectTypeTransaction represents a transaction object.
    ObjectTypeTransaction = 2,

} ObjectType;


typedef enum {

    // PartitionTypeDirectory .
    PartitionTypeDirectory = 1,

    // PartitionTypeBlockValidator .
    PartitionTypeBlockValidator = 2,

} PartitionType;


typedef enum {

    // SignatureTypeUnknown is used when the signature type is not known.
    SignatureTypeUnknown = 0,

    // SignatureTypeLegacyED25519 represents a legacy ED25519 signature.
    SignatureTypeLegacyED25519 = 1,

    // SignatureTypeED25519 represents an ED25519 signature.
    SignatureTypeED25519 = 2,

    // SignatureTypeRCD1 represents an RCD1 signature.
    SignatureTypeRCD1 = 3,

    // SignatureTypeReceipt represents a Merkle tree receipt.
    SignatureTypeReceipt = 4,

    // SignatureTypePartition is used when sending synthetic and system transactions.
    SignatureTypePartition = 5,

    // SignatureTypeSet is used when forwarding multiple signatures.
    SignatureTypeSet = 6,

    // SignatureTypeRemote is used when forwarding a signature from one partition to another.
    SignatureTypeRemote = 7,

    // SignatureTypeBTC represents an BTC signature.
    SignatureTypeBTC = 8,

    // SignatureTypeBTCLegacy represents an BTC signature with uncompressed public key.
    SignatureTypeBTCLegacy = 9,

    // SignatureTypeETH represents an ETH signature.
    SignatureTypeETH = 10,

    // SignatureTypeDelegated represents a signature for a delegated authority.
    SignatureTypeDelegated = 11,

    // SignatureTypeInternal is used for internally produced transactions.
    SignatureTypeInternal = 12,

} SignatureType;


typedef enum {

    // TransactionMaxUser is the highest number reserved for user transactions.
    TransactionMaxUser = 48,

    // TransactionMaxSynthetic is the highest number reserved for synthetic transactions.
    TransactionMaxSynthetic = 95,

    // TransactionMaxSystem is the highest number reserved for internal transactions.
    TransactionMaxSystem = 255,

} TransactionMax;


typedef enum {

    // TransactionTypeUnknown represents an unknown transaction type.
    TransactionTypeUnknown = 0,

    // TransactionTypeCreateIdentity creates an ADI, which produces a synthetic chain.
    TransactionTypeCreateIdentity = 1,

    // TransactionTypeCreateTokenAccount creates an ADI token account, which produces a synthetic chain create transaction.
    TransactionTypeCreateTokenAccount = 2,

    // TransactionTypeSendTokens transfers tokens between token accounts, which produces a synthetic deposit tokens transaction.
    TransactionTypeSendTokens = 3,

    // TransactionTypeCreateDataAccount creates an ADI Data Account, which produces a synthetic chain create transaction.
    TransactionTypeCreateDataAccount = 4,

    // TransactionTypeWriteData writes data to an ADI Data Account, which *does not* produce a synthetic transaction.
    TransactionTypeWriteData = 5,

    // TransactionTypeWriteDataTo writes data to a Lite Data Account, which produces a synthetic write data transaction.
    TransactionTypeWriteDataTo = 6,

    // TransactionTypeAcmeFaucet produces a synthetic deposit tokens transaction that deposits ACME tokens into a lite token account.
    TransactionTypeAcmeFaucet = 7,

    // TransactionTypeCreateToken creates a token issuer, which produces a synthetic chain create transaction.
    TransactionTypeCreateToken = 8,

    // TransactionTypeIssueTokens issues tokens to a token account, which produces a synthetic token deposit transaction.
    TransactionTypeIssueTokens = 9,

    // TransactionTypeBurnTokens burns tokens from a token account, which produces a synthetic burn tokens transaction.
    TransactionTypeBurnTokens = 10,

    // TransactionTypeCreateLiteTokenAccount create a lite token account.
    TransactionTypeCreateLiteTokenAccount = 11,

    // TransactionTypeCreateKeyPage creates a key page, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyPage = 12,

    // TransactionTypeCreateKeyBook creates a key book, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyBook = 13,

    // TransactionTypeAddCredits converts ACME tokens to credits, which produces a synthetic deposit credits transaction.
    TransactionTypeAddCredits = 14,

    // TransactionTypeUpdateKeyPage adds, removes, or updates keys in a key page, which *does not* produce a synthetic transaction.
    TransactionTypeUpdateKeyPage = 15,

    // TransactionTypeLockAccount sets a major block height that prevents tokens from being transferred out of a lite token account until that height has been reached.
    TransactionTypeLockAccount = 16,

    // TransactionTypeUpdateAccountAuth updates authorization for an account.
    TransactionTypeUpdateAccountAuth = 21,

    // TransactionTypeUpdateKey update key for existing keys.
    TransactionTypeUpdateKey = 22,

    // TransactionTypeRemote is used to sign a remote transaction.
    TransactionTypeRemote = 48,

    // TransactionTypeSyntheticCreateIdentity creates an identity.
    TransactionTypeSyntheticCreateIdentity = 49,

    // TransactionTypeSyntheticWriteData writes data to a data account.
    TransactionTypeSyntheticWriteData = 50,

    // TransactionTypeSyntheticDepositTokens deposits tokens into token accounts.
    TransactionTypeSyntheticDepositTokens = 51,

    // TransactionTypeSyntheticDepositCredits deposits credits into a credit holder.
    TransactionTypeSyntheticDepositCredits = 52,

    // TransactionTypeSyntheticBurnTokens returns tokens to a token issuer's pool of issuable tokens.
    TransactionTypeSyntheticBurnTokens = 53,

    // TransactionTypeSyntheticForwardTransaction forwards a transaction from one partition to another.
    TransactionTypeSyntheticForwardTransaction = 54,

    // TransactionTypeSystemGenesis initializes system chains.
    TransactionTypeSystemGenesis = 96,

    // TransactionTypeDirectoryAnchor anchors one network to another.
    TransactionTypeDirectoryAnchor = 97,

    // TransactionTypeBlockValidatorAnchor system transaction for partition data.
    TransactionTypeBlockValidatorAnchor = 98,

    // TransactionTypeSystemWriteData writes data to a system data account.
    TransactionTypeSystemWriteData = 99,

} TransactionType;


typedef enum {

    // VoteTypeAccept vote yea in favor of proposal.
    VoteTypeAccept = 0,

    // VoteTypeReject vote nay against a proposal.
    VoteTypeReject = 1,

    // VoteTypeAbstain chose not to vote on a proposal.
    VoteTypeAbstain = 2,

    // VoteTypeSuggest put forth a proposal.
    VoteTypeSuggest = 3,

} VoteType;




typedef struct {
    Bytes data;
} AccountAuthOperationType_t;

ACME_API uint64_t AccountAuthOperationType_ID(AccountAuthOperationType v);
ACME_API Error AccountAuthOperationType_fromString(AccountAuthOperationType *v, String *name);
ACME_API Error AccountAuthOperationType_asString(AccountAuthOperationType v, String *out);
//ACME_API Error AccountAuthOperationType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AccountAuthOperationType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API AccountAuthOperationType_t AccountAuthOperationType_init(AccountAuthOperationType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadAccountAuthOperationType(Unmarshaler *m, AccountAuthOperationType *v);
ACME_API int marshalerWriteAccountAuthOperationType(Marshaler *m, AccountAuthOperationType v);
ACME_API bool AccountAuthOperationType_equal(const AccountAuthOperationType *a, const AccountAuthOperationType *b);



typedef struct {
    Bytes data;
} AccountType_t;

ACME_API uint64_t AccountType_ID(AccountType v);
ACME_API Error AccountType_fromString(AccountType *v, String *name);
ACME_API Error AccountType_asString(AccountType v, String *out);
//ACME_API Error AccountType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AccountType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API AccountType_t AccountType_init(AccountType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadAccountType(Unmarshaler *m, AccountType *v);
ACME_API int marshalerWriteAccountType(Marshaler *m, AccountType v);
ACME_API bool AccountType_equal(const AccountType *a, const AccountType *b);



typedef struct {
    Bytes data;
} AllowedTransactionBit_t;

ACME_API uint64_t AllowedTransactionBit_ID(AllowedTransactionBit v);
ACME_API Error AllowedTransactionBit_fromString(AllowedTransactionBit *v, String *name);
ACME_API Error AllowedTransactionBit_asString(AllowedTransactionBit v, String *out);
//ACME_API Error AllowedTransactionBit_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AllowedTransactionBit_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API AllowedTransactionBit_t AllowedTransactionBit_init(AllowedTransactionBit_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadAllowedTransactionBit(Unmarshaler *m, AllowedTransactionBit *v);
ACME_API int marshalerWriteAllowedTransactionBit(Marshaler *m, AllowedTransactionBit v);
ACME_API bool AllowedTransactionBit_equal(const AllowedTransactionBit *a, const AllowedTransactionBit *b);



typedef struct {
    Bytes data;
} BookType_t;

ACME_API uint64_t BookType_ID(BookType v);
ACME_API Error BookType_fromString(BookType *v, String *name);
ACME_API Error BookType_asString(BookType v, String *out);
//ACME_API Error BookType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error BookType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API BookType_t BookType_init(BookType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadBookType(Unmarshaler *m, BookType *v);
ACME_API int marshalerWriteBookType(Marshaler *m, BookType v);
ACME_API bool BookType_equal(const BookType *a, const BookType *b);



typedef struct {
    Bytes data;
} DataEntryType_t;

ACME_API uint64_t DataEntryType_ID(DataEntryType v);
ACME_API Error DataEntryType_fromString(DataEntryType *v, String *name);
ACME_API Error DataEntryType_asString(DataEntryType v, String *out);
//ACME_API Error DataEntryType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error DataEntryType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API DataEntryType_t DataEntryType_init(DataEntryType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadDataEntryType(Unmarshaler *m, DataEntryType *v);
ACME_API int marshalerWriteDataEntryType(Marshaler *m, DataEntryType v);
ACME_API bool DataEntryType_equal(const DataEntryType *a, const DataEntryType *b);



typedef struct {
    Bytes data;
} KeyPageOperationType_t;

ACME_API uint64_t KeyPageOperationType_ID(KeyPageOperationType v);
ACME_API Error KeyPageOperationType_fromString(KeyPageOperationType *v, String *name);
ACME_API Error KeyPageOperationType_asString(KeyPageOperationType v, String *out);
//ACME_API Error KeyPageOperationType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error KeyPageOperationType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API KeyPageOperationType_t KeyPageOperationType_init(KeyPageOperationType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadKeyPageOperationType(Unmarshaler *m, KeyPageOperationType *v);
ACME_API int marshalerWriteKeyPageOperationType(Marshaler *m, KeyPageOperationType v);
ACME_API bool KeyPageOperationType_equal(const KeyPageOperationType *a, const KeyPageOperationType *b);



typedef struct {
    Bytes data;
} ObjectType_t;

ACME_API uint64_t ObjectType_ID(ObjectType v);
ACME_API Error ObjectType_fromString(ObjectType *v, String *name);
ACME_API Error ObjectType_asString(ObjectType v, String *out);
//ACME_API Error ObjectType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error ObjectType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API ObjectType_t ObjectType_init(ObjectType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadObjectType(Unmarshaler *m, ObjectType *v);
ACME_API int marshalerWriteObjectType(Marshaler *m, ObjectType v);
ACME_API bool ObjectType_equal(const ObjectType *a, const ObjectType *b);



typedef struct {
    Bytes data;
} PartitionType_t;

ACME_API uint64_t PartitionType_ID(PartitionType v);
ACME_API Error PartitionType_fromString(PartitionType *v, String *name);
ACME_API Error PartitionType_asString(PartitionType v, String *out);
//ACME_API Error PartitionType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error PartitionType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API PartitionType_t PartitionType_init(PartitionType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadPartitionType(Unmarshaler *m, PartitionType *v);
ACME_API int marshalerWritePartitionType(Marshaler *m, PartitionType v);
ACME_API bool PartitionType_equal(const PartitionType *a, const PartitionType *b);



typedef struct {
    Bytes data;
} SignatureType_t;

ACME_API uint64_t SignatureType_ID(SignatureType v);
ACME_API Error SignatureType_fromString(SignatureType *v, String *name);
ACME_API Error SignatureType_asString(SignatureType v, String *out);
//ACME_API Error SignatureType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error SignatureType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API SignatureType_t SignatureType_init(SignatureType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadSignatureType(Unmarshaler *m, SignatureType *v);
ACME_API int marshalerWriteSignatureType(Marshaler *m, SignatureType v);
ACME_API bool SignatureType_equal(const SignatureType *a, const SignatureType *b);



typedef struct {
    Bytes data;
} TransactionMax_t;

ACME_API uint64_t TransactionMax_ID(TransactionMax v);
ACME_API Error TransactionMax_fromString(TransactionMax *v, String *name);
ACME_API Error TransactionMax_asString(TransactionMax v, String *out);
//ACME_API Error TransactionMax_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error TransactionMax_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API TransactionMax_t TransactionMax_init(TransactionMax_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadTransactionMax(Unmarshaler *m, TransactionMax *v);
ACME_API int marshalerWriteTransactionMax(Marshaler *m, TransactionMax v);
ACME_API bool TransactionMax_equal(const TransactionMax *a, const TransactionMax *b);



typedef struct {
    Bytes data;
} TransactionType_t;

ACME_API uint64_t TransactionType_ID(TransactionType v);
ACME_API Error TransactionType_fromString(TransactionType *v, String *name);
ACME_API Error TransactionType_asString(TransactionType v, String *out);
//ACME_API Error TransactionType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error TransactionType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API TransactionType_t TransactionType_init(TransactionType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadTransactionType(Unmarshaler *m, TransactionType *v);
ACME_API int marshalerWriteTransactionType(Marshaler *m, TransactionType v);
ACME_API bool TransactionType_equal(const TransactionType *a, const TransactionType *b);



typedef struct {
    Bytes data;
} VoteType_t;

ACME_API uint64_t VoteType_ID(VoteType v);
ACME_API Error VoteType_fromString(VoteType *v, String *name);
ACME_API Error VoteType_asString(VoteType v, String *out);
//ACME_API Error VoteType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error VoteType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API VoteType_t VoteType_init(VoteType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadVoteType(Unmarshaler *m, VoteType *v);
ACME_API int marshalerWriteVoteType(Marshaler *m, VoteType v);
ACME_API bool VoteType_equal(const VoteType *a, const VoteType *b);



#ifdef _ACME_ENUM_SOURCE_




ACME_API Error AccountAuthOperationType_set(VarInt *v, AccountAuthOperationType n) {
    return VarInt_set(v,n);
}

ACME_API Error AccountAuthOperationType_get(const VarInt *v, AccountAuthOperationType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Account Auth Operation Type
ACME_API uint64_t AccountAuthOperationType_ID(AccountAuthOperationType v) { return (uint64_t)(v); }

// String returns the name of the Account Auth Operation Type
static enum_t AccountAuthOperationType_l[] = {
	{ "unknown", AccountAuthOperationTypeUnknown },
	{ "enable", AccountAuthOperationTypeEnable },
	{ "disable", AccountAuthOperationTypeDisable },
	{ "addauthority", AccountAuthOperationTypeAddAuthority },
	{ "removeauthority", AccountAuthOperationTypeRemoveAuthority },
	{ 0,0 },
};

ACME_API Error AccountAuthOperationType_asString(const AccountAuthOperationType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountAuthOperationType_l[i].name == 0 ) {
            break;
        }
        if ( AccountAuthOperationType_l[i].e == v ) {
            String_set(out, AccountAuthOperationType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AccountAuthOperationTypeByName returns the named Account Auth Operation Type.
ACME_API Error AccountAuthOperationType_fromString(AccountAuthOperationType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountAuthOperationType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(AccountAuthOperationType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = AccountAuthOperationType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool AccountAuthOperationType_equal(const AccountAuthOperationType *a, const AccountAuthOperationType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Account Auth Operation Type to bytes as a unsigned varint.
ACME_API int marshalerWriteAccountAuthOperationType(Marshaler *m, AccountAuthOperationType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Account Auth Operation Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadAccountAuthOperationType(Unmarshaler *m, AccountAuthOperationType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = AccountAuthOperationType)n;
	return b;
}



ACME_API Error AccountType_set(VarInt *v, AccountType n) {
    return VarInt_set(v,n);
}

ACME_API Error AccountType_get(const VarInt *v, AccountType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Account Type
ACME_API uint64_t AccountType_ID(AccountType v) { return (uint64_t)(v); }

// String returns the name of the Account Type
static enum_t AccountType_l[] = {
	{ "unknown", AccountTypeUnknown },
	{ "anchorledger", AccountTypeAnchorLedger },
	{ "identity", AccountTypeIdentity },
	{ "tokenissuer", AccountTypeTokenIssuer },
	{ "tokenaccount", AccountTypeTokenAccount },
	{ "litetokenaccount", AccountTypeLiteTokenAccount },
	{ "blockledger", AccountTypeBlockLedger },
	{ "keypage", AccountTypeKeyPage },
	{ "keybook", AccountTypeKeyBook },
	{ "dataaccount", AccountTypeDataAccount },
	{ "litedataaccount", AccountTypeLiteDataAccount },
	{ "unknownsigner", AccountTypeUnknownSigner },
	{ "systemledger", AccountTypeSystemLedger },
	{ "liteidentity", AccountTypeLiteIdentity },
	{ "syntheticledger", AccountTypeSyntheticLedger },
	{ 0,0 },
};

ACME_API Error AccountType_asString(const AccountType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountType_l[i].name == 0 ) {
            break;
        }
        if ( AccountType_l[i].e == v ) {
            String_set(out, AccountType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AccountTypeByName returns the named Account Type.
ACME_API Error AccountType_fromString(AccountType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(AccountType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = AccountType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool AccountType_equal(const AccountType *a, const AccountType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Account Type to bytes as a unsigned varint.
ACME_API int marshalerWriteAccountType(Marshaler *m, AccountType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Account Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadAccountType(Unmarshaler *m, AccountType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = AccountType)n;
	return b;
}



ACME_API Error AllowedTransactionBit_set(VarInt *v, AllowedTransactionBit n) {
    return VarInt_set(v,n);
}

ACME_API Error AllowedTransactionBit_get(const VarInt *v, AllowedTransactionBit *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Allowed Transaction Bit
ACME_API uint64_t AllowedTransactionBit_ID(AllowedTransactionBit v) { return (uint64_t)(v); }

// String returns the name of the Allowed Transaction Bit
static enum_t AllowedTransactionBit_l[] = {
	{ "updatekeypage", AllowedTransactionBitUpdateKeyPage },
	{ "updateaccountauth", AllowedTransactionBitUpdateAccountAuth },
	{ 0,0 },
};

ACME_API Error AllowedTransactionBit_asString(const AllowedTransactionBit v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AllowedTransactionBit_l[i].name == 0 ) {
            break;
        }
        if ( AllowedTransactionBit_l[i].e == v ) {
            String_set(out, AllowedTransactionBit_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AllowedTransactionBitByName returns the named Allowed Transaction Bit.
ACME_API Error AllowedTransactionBit_fromString(AllowedTransactionBit *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AllowedTransactionBit_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(AllowedTransactionBit_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = AllowedTransactionBit_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool AllowedTransactionBit_equal(const AllowedTransactionBit *a, const AllowedTransactionBit *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Allowed Transaction Bit to bytes as a unsigned varint.
ACME_API int marshalerWriteAllowedTransactionBit(Marshaler *m, AllowedTransactionBit v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Allowed Transaction Bit from bytes as a unsigned varint.
ACME_API int unmarshalerReadAllowedTransactionBit(Unmarshaler *m, AllowedTransactionBit *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = AllowedTransactionBit)n;
	return b;
}



ACME_API Error BookType_set(VarInt *v, BookType n) {
    return VarInt_set(v,n);
}

ACME_API Error BookType_get(const VarInt *v, BookType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Book Type
ACME_API uint64_t BookType_ID(BookType v) { return (uint64_t)(v); }

// String returns the name of the Book Type
static enum_t BookType_l[] = {
	{ "normal", BookTypeNormal },
	{ "validator", BookTypeValidator },
	{ "operator", BookTypeOperator },
	{ 0,0 },
};

ACME_API Error BookType_asString(const BookType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( BookType_l[i].name == 0 ) {
            break;
        }
        if ( BookType_l[i].e == v ) {
            String_set(out, BookType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// BookTypeByName returns the named Book Type.
ACME_API Error BookType_fromString(BookType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( BookType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(BookType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = BookType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool BookType_equal(const BookType *a, const BookType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Book Type to bytes as a unsigned varint.
ACME_API int marshalerWriteBookType(Marshaler *m, BookType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Book Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadBookType(Unmarshaler *m, BookType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = BookType)n;
	return b;
}



ACME_API Error DataEntryType_set(VarInt *v, DataEntryType n) {
    return VarInt_set(v,n);
}

ACME_API Error DataEntryType_get(const VarInt *v, DataEntryType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Data Entry Type
ACME_API uint64_t DataEntryType_ID(DataEntryType v) { return (uint64_t)(v); }

// String returns the name of the Data Entry Type
static enum_t DataEntryType_l[] = {
	{ "unknown", DataEntryTypeUnknown },
	{ "factom", DataEntryTypeFactom },
	{ "accumulate", DataEntryTypeAccumulate },
	{ 0,0 },
};

ACME_API Error DataEntryType_asString(const DataEntryType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( DataEntryType_l[i].name == 0 ) {
            break;
        }
        if ( DataEntryType_l[i].e == v ) {
            String_set(out, DataEntryType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// DataEntryTypeByName returns the named Data Entry Type.
ACME_API Error DataEntryType_fromString(DataEntryType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( DataEntryType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(DataEntryType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = DataEntryType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool DataEntryType_equal(const DataEntryType *a, const DataEntryType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Data Entry Type to bytes as a unsigned varint.
ACME_API int marshalerWriteDataEntryType(Marshaler *m, DataEntryType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Data Entry Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadDataEntryType(Unmarshaler *m, DataEntryType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = DataEntryType)n;
	return b;
}



ACME_API Error KeyPageOperationType_set(VarInt *v, KeyPageOperationType n) {
    return VarInt_set(v,n);
}

ACME_API Error KeyPageOperationType_get(const VarInt *v, KeyPageOperationType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Key Page Operation Type
ACME_API uint64_t KeyPageOperationType_ID(KeyPageOperationType v) { return (uint64_t)(v); }

// String returns the name of the Key Page Operation Type
static enum_t KeyPageOperationType_l[] = {
	{ "unknown", KeyPageOperationTypeUnknown },
	{ "update", KeyPageOperationTypeUpdate },
	{ "remove", KeyPageOperationTypeRemove },
	{ "add", KeyPageOperationTypeAdd },
	{ "setthreshold", KeyPageOperationTypeSetThreshold },
	{ "updateallowed", KeyPageOperationTypeUpdateAllowed },
	{ 0,0 },
};

ACME_API Error KeyPageOperationType_asString(const KeyPageOperationType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( KeyPageOperationType_l[i].name == 0 ) {
            break;
        }
        if ( KeyPageOperationType_l[i].e == v ) {
            String_set(out, KeyPageOperationType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// KeyPageOperationTypeByName returns the named Key Page Operation Type.
ACME_API Error KeyPageOperationType_fromString(KeyPageOperationType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( KeyPageOperationType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(KeyPageOperationType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = KeyPageOperationType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool KeyPageOperationType_equal(const KeyPageOperationType *a, const KeyPageOperationType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Key Page Operation Type to bytes as a unsigned varint.
ACME_API int marshalerWriteKeyPageOperationType(Marshaler *m, KeyPageOperationType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Key Page Operation Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadKeyPageOperationType(Unmarshaler *m, KeyPageOperationType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = KeyPageOperationType)n;
	return b;
}



ACME_API Error ObjectType_set(VarInt *v, ObjectType n) {
    return VarInt_set(v,n);
}

ACME_API Error ObjectType_get(const VarInt *v, ObjectType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Object Type
ACME_API uint64_t ObjectType_ID(ObjectType v) { return (uint64_t)(v); }

// String returns the name of the Object Type
static enum_t ObjectType_l[] = {
	{ "unknown", ObjectTypeUnknown },
	{ "account", ObjectTypeAccount },
	{ "transaction", ObjectTypeTransaction },
	{ 0,0 },
};

ACME_API Error ObjectType_asString(const ObjectType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( ObjectType_l[i].name == 0 ) {
            break;
        }
        if ( ObjectType_l[i].e == v ) {
            String_set(out, ObjectType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// ObjectTypeByName returns the named Object Type.
ACME_API Error ObjectType_fromString(ObjectType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( ObjectType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(ObjectType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = ObjectType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool ObjectType_equal(const ObjectType *a, const ObjectType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Object Type to bytes as a unsigned varint.
ACME_API int marshalerWriteObjectType(Marshaler *m, ObjectType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Object Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadObjectType(Unmarshaler *m, ObjectType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = ObjectType)n;
	return b;
}



ACME_API Error PartitionType_set(VarInt *v, PartitionType n) {
    return VarInt_set(v,n);
}

ACME_API Error PartitionType_get(const VarInt *v, PartitionType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Partition Type
ACME_API uint64_t PartitionType_ID(PartitionType v) { return (uint64_t)(v); }

// String returns the name of the Partition Type
static enum_t PartitionType_l[] = {
	{ "directory", PartitionTypeDirectory },
	{ "blockvalidator", PartitionTypeBlockValidator },
	{ 0,0 },
};

ACME_API Error PartitionType_asString(const PartitionType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( PartitionType_l[i].name == 0 ) {
            break;
        }
        if ( PartitionType_l[i].e == v ) {
            String_set(out, PartitionType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// PartitionTypeByName returns the named Partition Type.
ACME_API Error PartitionType_fromString(PartitionType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( PartitionType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(PartitionType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = PartitionType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool PartitionType_equal(const PartitionType *a, const PartitionType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Partition Type to bytes as a unsigned varint.
ACME_API int marshalerWritePartitionType(Marshaler *m, PartitionType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Partition Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadPartitionType(Unmarshaler *m, PartitionType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = PartitionType)n;
	return b;
}



ACME_API Error SignatureType_set(VarInt *v, SignatureType n) {
    return VarInt_set(v,n);
}

ACME_API Error SignatureType_get(const VarInt *v, SignatureType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Signature Type
ACME_API uint64_t SignatureType_ID(SignatureType v) { return (uint64_t)(v); }

// String returns the name of the Signature Type
static enum_t SignatureType_l[] = {
	{ "unknown", SignatureTypeUnknown },
	{ "legacyed25519", SignatureTypeLegacyED25519 },
	{ "ed25519", SignatureTypeED25519 },
	{ "rcd1", SignatureTypeRCD1 },
	{ "receipt", SignatureTypeReceipt },
	{ "partition", SignatureTypePartition },
	{ "set", SignatureTypeSet },
	{ "remote", SignatureTypeRemote },
	{ "btc", SignatureTypeBTC },
	{ "btclegacy", SignatureTypeBTCLegacy },
	{ "eth", SignatureTypeETH },
	{ "delegated", SignatureTypeDelegated },
	{ "internal", SignatureTypeInternal },
	{ 0,0 },
};

ACME_API Error SignatureType_asString(const SignatureType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( SignatureType_l[i].name == 0 ) {
            break;
        }
        if ( SignatureType_l[i].e == v ) {
            String_set(out, SignatureType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// SignatureTypeByName returns the named Signature Type.
ACME_API Error SignatureType_fromString(SignatureType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( SignatureType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(SignatureType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = SignatureType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool SignatureType_equal(const SignatureType *a, const SignatureType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Signature Type to bytes as a unsigned varint.
ACME_API int marshalerWriteSignatureType(Marshaler *m, SignatureType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Signature Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadSignatureType(Unmarshaler *m, SignatureType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = SignatureType)n;
	return b;
}



ACME_API Error TransactionMax_set(VarInt *v, TransactionMax n) {
    return VarInt_set(v,n);
}

ACME_API Error TransactionMax_get(const VarInt *v, TransactionMax *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Transaction Max
ACME_API uint64_t TransactionMax_ID(TransactionMax v) { return (uint64_t)(v); }

// String returns the name of the Transaction Max
static enum_t TransactionMax_l[] = {
	{ "user", TransactionMaxUser },
	{ "synthetic", TransactionMaxSynthetic },
	{ "system", TransactionMaxSystem },
	{ 0,0 },
};

ACME_API Error TransactionMax_asString(const TransactionMax v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionMax_l[i].name == 0 ) {
            break;
        }
        if ( TransactionMax_l[i].e == v ) {
            String_set(out, TransactionMax_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// TransactionMaxByName returns the named Transaction Max.
ACME_API Error TransactionMax_fromString(TransactionMax *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionMax_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(TransactionMax_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = TransactionMax_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool TransactionMax_equal(const TransactionMax *a, const TransactionMax *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Transaction Max to bytes as a unsigned varint.
ACME_API int marshalerWriteTransactionMax(Marshaler *m, TransactionMax v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Transaction Max from bytes as a unsigned varint.
ACME_API int unmarshalerReadTransactionMax(Unmarshaler *m, TransactionMax *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = TransactionMax)n;
	return b;
}



ACME_API Error TransactionType_set(VarInt *v, TransactionType n) {
    return VarInt_set(v,n);
}

ACME_API Error TransactionType_get(const VarInt *v, TransactionType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Transaction Type
ACME_API uint64_t TransactionType_ID(TransactionType v) { return (uint64_t)(v); }

// String returns the name of the Transaction Type
static enum_t TransactionType_l[] = {
	{ "unknown", TransactionTypeUnknown },
	{ "createidentity", TransactionTypeCreateIdentity },
	{ "createtokenaccount", TransactionTypeCreateTokenAccount },
	{ "sendtokens", TransactionTypeSendTokens },
	{ "createdataaccount", TransactionTypeCreateDataAccount },
	{ "writedata", TransactionTypeWriteData },
	{ "writedatato", TransactionTypeWriteDataTo },
	{ "acmefaucet", TransactionTypeAcmeFaucet },
	{ "createtoken", TransactionTypeCreateToken },
	{ "issuetokens", TransactionTypeIssueTokens },
	{ "burntokens", TransactionTypeBurnTokens },
	{ "createlitetokenaccount", TransactionTypeCreateLiteTokenAccount },
	{ "createkeypage", TransactionTypeCreateKeyPage },
	{ "createkeybook", TransactionTypeCreateKeyBook },
	{ "addcredits", TransactionTypeAddCredits },
	{ "updatekeypage", TransactionTypeUpdateKeyPage },
	{ "lockaccount", TransactionTypeLockAccount },
	{ "updateaccountauth", TransactionTypeUpdateAccountAuth },
	{ "updatekey", TransactionTypeUpdateKey },
	{ "remote", TransactionTypeRemote },
	{ "syntheticcreateidentity", TransactionTypeSyntheticCreateIdentity },
	{ "syntheticwritedata", TransactionTypeSyntheticWriteData },
	{ "syntheticdeposittokens", TransactionTypeSyntheticDepositTokens },
	{ "syntheticdepositcredits", TransactionTypeSyntheticDepositCredits },
	{ "syntheticburntokens", TransactionTypeSyntheticBurnTokens },
	{ "syntheticforwardtransaction", TransactionTypeSyntheticForwardTransaction },
	{ "systemgenesis", TransactionTypeSystemGenesis },
	{ "directoryanchor", TransactionTypeDirectoryAnchor },
	{ "blockvalidatoranchor", TransactionTypeBlockValidatorAnchor },
	{ "systemwritedata", TransactionTypeSystemWriteData },
	{ 0,0 },
};

ACME_API Error TransactionType_asString(const TransactionType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionType_l[i].name == 0 ) {
            break;
        }
        if ( TransactionType_l[i].e == v ) {
            String_set(out, TransactionType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// TransactionTypeByName returns the named Transaction Type.
ACME_API Error TransactionType_fromString(TransactionType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(TransactionType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = TransactionType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool TransactionType_equal(const TransactionType *a, const TransactionType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Transaction Type to bytes as a unsigned varint.
ACME_API int marshalerWriteTransactionType(Marshaler *m, TransactionType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Transaction Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadTransactionType(Unmarshaler *m, TransactionType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = TransactionType)n;
	return b;
}



ACME_API Error VoteType_set(VarInt *v, VoteType n) {
    return VarInt_set(v,n);
}

ACME_API Error VoteType_get(const VarInt *v, VoteType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Vote Type
ACME_API uint64_t VoteType_ID(VoteType v) { return (uint64_t)(v); }

// String returns the name of the Vote Type
static enum_t VoteType_l[] = {
	{ "accept", VoteTypeAccept },
	{ "reject", VoteTypeReject },
	{ "abstain", VoteTypeAbstain },
	{ "suggest", VoteTypeSuggest },
	{ 0,0 },
};

ACME_API Error VoteType_asString(const VoteType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( VoteType_l[i].name == 0 ) {
            break;
        }
        if ( VoteType_l[i].e == v ) {
            String_set(out, VoteType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// VoteTypeByName returns the named Vote Type.
ACME_API Error VoteType_fromString(VoteType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( VoteType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(VoteType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = VoteType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

ACME_API bool VoteType_equal(const VoteType *a, const VoteType *b) {
    if (!a || !b) {
        return false;
    }
    return *a == *b;
}

// MarshalBinary marshals the Vote Type to bytes as a unsigned varint.
ACME_API int marshalerWriteVoteType(Marshaler *m, VoteType v) {
    return marshalerWriteUInt(m,(uint64_t) v);
}


// UnmarshalBinary unmarshals the Vote Type from bytes as a unsigned varint.
ACME_API int unmarshalerReadVoteType(Unmarshaler *m, VoteType *v) {
	uint64_t n = 0;
	int b = unmarshalerReadInt(m, (int64_t*)v);
	*v = VoteType)n;
	return b;
}



#endif /* _ACME_ENUM_SOURCE_ */

#ifdef __cplusplus
}
#endif
