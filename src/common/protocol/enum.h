#pragma once

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif
#include <common/encoding/encoding.h>
#include <common/encoding/marshaler.h>

typedef struct {
   const char *name;
   uint32_t e;
} enum_t;



typedef enum {

    // AccountAuthOperationTypeUnknown is used when the authorization operation is not known.
    AccountAuthOperationTypeUnknown = 0,

    // AccountAuthOperationTypeEnable enables authorization checks for an authority.
    AccountAuthOperationTypeEnable = 1,

    // AccountAuthOperationTypeDisable disables authorization checks for an authority.
    AccountAuthOperationTypeDisable = 2,

    // AccountAuthOperationTypeAddAuthority adds an authority.
    AccountAuthOperationTypeAddAuthority = 3,

    // AccountAuthOperationTypeRemoveAuthority removes an authority.
    AccountAuthOperationTypeRemoveAuthority = 4,

} AccountAuthOperationType;


typedef enum {

    // AccountTypeUnknown represents an unknown account type.
    AccountTypeUnknown = 0,

    // AccountTypeAnchorLedger anchors the other partitions.
    AccountTypeAnchorLedger = 1,

    // AccountTypeIdentity is an Identity account, aka an ADI.
    AccountTypeIdentity = 2,

    // AccountTypeTokenIssuer is a Token Issuer account.
    AccountTypeTokenIssuer = 3,

    // AccountTypeTokenAccount is an ADI Token Account.
    AccountTypeTokenAccount = 4,

    // AccountTypeLiteTokenAccount is a Lite Token Account.
    AccountTypeLiteTokenAccount = 5,

    // AccountTypeBlockLedger is a Block Ledger account.
    AccountTypeBlockLedger = 6,

    // AccountTypeKeyPage is a Key Page account.
    AccountTypeKeyPage = 9,

    // AccountTypeKeyBook is a Key Book account.
    AccountTypeKeyBook = 10,

    // AccountTypeDataAccount is an ADI Data Account.
    AccountTypeDataAccount = 11,

    // AccountTypeLiteDataAccount is a Lite Data Account.
    AccountTypeLiteDataAccount = 12,

    // AccountTypeUnknownSigner represents an unknown signer account.
    AccountTypeUnknownSigner = 13,

    // AccountTypeSystemLedger is a ledger that tracks the state of internal operations.
    AccountTypeSystemLedger = 14,

    // AccountTypeLiteIdentity is a lite identity account.
    AccountTypeLiteIdentity = 15,

    // AccountTypeSyntheticLedger is a ledger that tracks the status of produced and received synthetic transactions.
    AccountTypeSyntheticLedger = 16,

} AccountType;


typedef enum {

    // AllowedTransactionBitUpdateKeyPage is the offset of the UpdateKeyPage bit.
    AllowedTransactionBitUpdateKeyPage = 1,

    // AllowedTransactionBitUpdateAccountAuth is the offset of the UpdateAccountAuth bit.
    AllowedTransactionBitUpdateAccountAuth = 2,

} AllowedTransactionBit;


typedef enum {

    // BookTypeNormal is a normal key book.
    BookTypeNormal = 0,

    // BookTypeValidator is a validator key book.
    BookTypeValidator = 1,

    // BookTypeOperator Operator key book.
    BookTypeOperator = 2,

} BookType;


typedef enum {

    // DataEntryTypeUnknown .
    DataEntryTypeUnknown = 0,

    // DataEntryTypeFactom .
    DataEntryTypeFactom = 1,

    // DataEntryTypeAccumulate .
    DataEntryTypeAccumulate = 2,

} DataEntryType;


typedef enum {

    // KeyPageOperationTypeUnknown is used when the key page operation is not known.
    KeyPageOperationTypeUnknown = 0,

    // KeyPageOperationTypeUpdate replaces a key in the page with a new key.
    KeyPageOperationTypeUpdate = 1,

    // KeyPageOperationTypeRemove removes a key from the page.
    KeyPageOperationTypeRemove = 2,

    // KeyPageOperationTypeAdd adds a key to the page.
    KeyPageOperationTypeAdd = 3,

    // KeyPageOperationTypeSetThreshold sets the signing threshold (the M of "M of N" signatures required).
    KeyPageOperationTypeSetThreshold = 4,

    // KeyPageOperationTypeUpdateAllowed updates the transactions the key page is allowed to execute.
    KeyPageOperationTypeUpdateAllowed = 5,

} KeyPageOperationType;


typedef enum {

    // ObjectTypeUnknown is used when the object type is not known.
    ObjectTypeUnknown = 0,

    // ObjectTypeAccount represents an account object.
    ObjectTypeAccount = 1,

    // ObjectTypeTransaction represents a transaction object.
    ObjectTypeTransaction = 2,

} ObjectType;


typedef enum {

    // PartitionTypeDirectory .
    PartitionTypeDirectory = 1,

    // PartitionTypeBlockValidator .
    PartitionTypeBlockValidator = 2,

} PartitionType;


typedef enum {

    // SignatureTypeUnknown is used when the signature type is not known.
    SignatureTypeUnknown = 0,

    // SignatureTypeLegacyED25519 represents a legacy ED25519 signature.
    SignatureTypeLegacyED25519 = 1,

    // SignatureTypeED25519 represents an ED25519 signature.
    SignatureTypeED25519 = 2,

    // SignatureTypeRCD1 represents an RCD1 signature.
    SignatureTypeRCD1 = 3,

    // SignatureTypeReceipt represents a Merkle tree receipt.
    SignatureTypeReceipt = 4,

    // SignatureTypePartition is used when sending synthetic and system transactions.
    SignatureTypePartition = 5,

    // SignatureTypeSet is used when forwarding multiple signatures.
    SignatureTypeSet = 6,

    // SignatureTypeRemote is used when forwarding a signature from one partition to another.
    SignatureTypeRemote = 7,

    // SignatureTypeBTC represents an BTC signature.
    SignatureTypeBTC = 8,

    // SignatureTypeBTCLegacy represents an BTC signature with uncompressed public key.
    SignatureTypeBTCLegacy = 9,

    // SignatureTypeETH represents an ETH signature.
    SignatureTypeETH = 10,

    // SignatureTypeDelegated represents a signature for a delegated authority.
    SignatureTypeDelegated = 11,

    // SignatureTypeInternal is used for internally produced transactions.
    SignatureTypeInternal = 12,

} SignatureType;


typedef enum {

    // TransactionMaxUser is the highest number reserved for user transactions.
    TransactionMaxUser = 48,

    // TransactionMaxSynthetic is the highest number reserved for synthetic transactions.
    TransactionMaxSynthetic = 95,

    // TransactionMaxSystem is the highest number reserved for internal transactions.
    TransactionMaxSystem = 255,

} TransactionMax;


typedef enum {

    // TransactionTypeUnknown represents an unknown transaction type.
    TransactionTypeUnknown = 0,

    // TransactionTypeCreateIdentity creates an ADI, which produces a synthetic chain.
    TransactionTypeCreateIdentity = 1,

    // TransactionTypeCreateTokenAccount creates an ADI token account, which produces a synthetic chain create transaction.
    TransactionTypeCreateTokenAccount = 2,

    // TransactionTypeSendTokens transfers tokens between token accounts, which produces a synthetic deposit tokens transaction.
    TransactionTypeSendTokens = 3,

    // TransactionTypeCreateDataAccount creates an ADI Data Account, which produces a synthetic chain create transaction.
    TransactionTypeCreateDataAccount = 4,

    // TransactionTypeWriteData writes data to an ADI Data Account, which *does not* produce a synthetic transaction.
    TransactionTypeWriteData = 5,

    // TransactionTypeWriteDataTo writes data to a Lite Data Account, which produces a synthetic write data transaction.
    TransactionTypeWriteDataTo = 6,

    // TransactionTypeAcmeFaucet produces a synthetic deposit tokens transaction that deposits ACME tokens into a lite token account.
    TransactionTypeAcmeFaucet = 7,

    // TransactionTypeCreateToken creates a token issuer, which produces a synthetic chain create transaction.
    TransactionTypeCreateToken = 8,

    // TransactionTypeIssueTokens issues tokens to a token account, which produces a synthetic token deposit transaction.
    TransactionTypeIssueTokens = 9,

    // TransactionTypeBurnTokens burns tokens from a token account, which produces a synthetic burn tokens transaction.
    TransactionTypeBurnTokens = 10,

    // TransactionTypeCreateLiteTokenAccount create a lite token account.
    TransactionTypeCreateLiteTokenAccount = 11,

    // TransactionTypeCreateKeyPage creates a key page, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyPage = 12,

    // TransactionTypeCreateKeyBook creates a key book, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyBook = 13,

    // TransactionTypeAddCredits converts ACME tokens to credits, which produces a synthetic deposit credits transaction.
    TransactionTypeAddCredits = 14,

    // TransactionTypeUpdateKeyPage adds, removes, or updates keys in a key page, which *does not* produce a synthetic transaction.
    TransactionTypeUpdateKeyPage = 15,

    // TransactionTypeLockAccount sets a major block height that prevents tokens from being transferred out of a lite token account until that height has been reached.
    TransactionTypeLockAccount = 16,

    // TransactionTypeUpdateAccountAuth updates authorization for an account.
    TransactionTypeUpdateAccountAuth = 21,

    // TransactionTypeUpdateKey update key for existing keys.
    TransactionTypeUpdateKey = 22,

    // TransactionTypeRemote is used to sign a remote transaction.
    TransactionTypeRemote = 48,

    // TransactionTypeSyntheticCreateIdentity creates an identity.
    TransactionTypeSyntheticCreateIdentity = 49,

    // TransactionTypeSyntheticWriteData writes data to a data account.
    TransactionTypeSyntheticWriteData = 50,

    // TransactionTypeSyntheticDepositTokens deposits tokens into token accounts.
    TransactionTypeSyntheticDepositTokens = 51,

    // TransactionTypeSyntheticDepositCredits deposits credits into a credit holder.
    TransactionTypeSyntheticDepositCredits = 52,

    // TransactionTypeSyntheticBurnTokens returns tokens to a token issuer's pool of issuable tokens.
    TransactionTypeSyntheticBurnTokens = 53,

    // TransactionTypeSyntheticForwardTransaction forwards a transaction from one partition to another.
    TransactionTypeSyntheticForwardTransaction = 54,

    // TransactionTypeSystemGenesis initializes system chains.
    TransactionTypeSystemGenesis = 96,

    // TransactionTypeDirectoryAnchor anchors one network to another.
    TransactionTypeDirectoryAnchor = 97,

    // TransactionTypeBlockValidatorAnchor system transaction for partition data.
    TransactionTypeBlockValidatorAnchor = 98,

    // TransactionTypeSystemWriteData writes data to a system data account.
    TransactionTypeSystemWriteData = 99,

} TransactionType;


typedef enum {

    // VoteTypeAccept vote yea in favor of proposal.
    VoteTypeAccept = 0,

    // VoteTypeReject vote nay against a proposal.
    VoteTypeReject = 1,

    // VoteTypeAbstain chose not to vote on a proposal.
    VoteTypeAbstain = 2,

    // VoteTypeSuggest put forth a proposal.
    VoteTypeSuggest = 3,

} VoteType;




typedef struct {
    Bytes data;
} AccountAuthOperationType_t;

ACME_API uint64_t AccountAuthOperationType_ID(AccountAuthOperationType v);
ACME_API Error AccountAuthOperationType_fromString(AccountAuthOperationType *v, String *name);
ACME_API Error AccountAuthOperationType_asString(AccountAuthOperationType v, String *out);
//ACME_API Error AccountAuthOperationType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AccountAuthOperationType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API AccountAuthOperationType_t AccountAuthOperationType_init(AccountAuthOperationType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadAccountAuthOperationType(Unmarshaler *m, AccountAuthOperationType *v);
ACME_API int marshalerWriteAccountAuthOperationType(Marshaler *m, AccountAuthOperationType v);
ACME_API bool AccountAuthOperationType_equal(const AccountAuthOperationType *a, const AccountAuthOperationType *b);



typedef struct {
    Bytes data;
} AccountType_t;

ACME_API uint64_t AccountType_ID(AccountType v);
ACME_API Error AccountType_fromString(AccountType *v, String *name);
ACME_API Error AccountType_asString(AccountType v, String *out);
//ACME_API Error AccountType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AccountType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API AccountType_t AccountType_init(AccountType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadAccountType(Unmarshaler *m, AccountType *v);
ACME_API int marshalerWriteAccountType(Marshaler *m, AccountType v);
ACME_API bool AccountType_equal(const AccountType *a, const AccountType *b);



typedef struct {
    Bytes data;
} AllowedTransactionBit_t;

ACME_API uint64_t AllowedTransactionBit_ID(AllowedTransactionBit v);
ACME_API Error AllowedTransactionBit_fromString(AllowedTransactionBit *v, String *name);
ACME_API Error AllowedTransactionBit_asString(AllowedTransactionBit v, String *out);
//ACME_API Error AllowedTransactionBit_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AllowedTransactionBit_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API AllowedTransactionBit_t AllowedTransactionBit_init(AllowedTransactionBit_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadAllowedTransactionBit(Unmarshaler *m, AllowedTransactionBit *v);
ACME_API int marshalerWriteAllowedTransactionBit(Marshaler *m, AllowedTransactionBit v);
ACME_API bool AllowedTransactionBit_equal(const AllowedTransactionBit *a, const AllowedTransactionBit *b);



typedef struct {
    Bytes data;
} BookType_t;

ACME_API uint64_t BookType_ID(BookType v);
ACME_API Error BookType_fromString(BookType *v, String *name);
ACME_API Error BookType_asString(BookType v, String *out);
//ACME_API Error BookType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error BookType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API BookType_t BookType_init(BookType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadBookType(Unmarshaler *m, BookType *v);
ACME_API int marshalerWriteBookType(Marshaler *m, BookType v);
ACME_API bool BookType_equal(const BookType *a, const BookType *b);



typedef struct {
    Bytes data;
} DataEntryType_t;

ACME_API uint64_t DataEntryType_ID(DataEntryType v);
ACME_API Error DataEntryType_fromString(DataEntryType *v, String *name);
ACME_API Error DataEntryType_asString(DataEntryType v, String *out);
//ACME_API Error DataEntryType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error DataEntryType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API DataEntryType_t DataEntryType_init(DataEntryType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadDataEntryType(Unmarshaler *m, DataEntryType *v);
ACME_API int marshalerWriteDataEntryType(Marshaler *m, DataEntryType v);
ACME_API bool DataEntryType_equal(const DataEntryType *a, const DataEntryType *b);



typedef struct {
    Bytes data;
} KeyPageOperationType_t;

ACME_API uint64_t KeyPageOperationType_ID(KeyPageOperationType v);
ACME_API Error KeyPageOperationType_fromString(KeyPageOperationType *v, String *name);
ACME_API Error KeyPageOperationType_asString(KeyPageOperationType v, String *out);
//ACME_API Error KeyPageOperationType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error KeyPageOperationType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API KeyPageOperationType_t KeyPageOperationType_init(KeyPageOperationType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadKeyPageOperationType(Unmarshaler *m, KeyPageOperationType *v);
ACME_API int marshalerWriteKeyPageOperationType(Marshaler *m, KeyPageOperationType v);
ACME_API bool KeyPageOperationType_equal(const KeyPageOperationType *a, const KeyPageOperationType *b);



typedef struct {
    Bytes data;
} ObjectType_t;

ACME_API uint64_t ObjectType_ID(ObjectType v);
ACME_API Error ObjectType_fromString(ObjectType *v, String *name);
ACME_API Error ObjectType_asString(ObjectType v, String *out);
//ACME_API Error ObjectType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error ObjectType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API ObjectType_t ObjectType_init(ObjectType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadObjectType(Unmarshaler *m, ObjectType *v);
ACME_API int marshalerWriteObjectType(Marshaler *m, ObjectType v);
ACME_API bool ObjectType_equal(const ObjectType *a, const ObjectType *b);



typedef struct {
    Bytes data;
} PartitionType_t;

ACME_API uint64_t PartitionType_ID(PartitionType v);
ACME_API Error PartitionType_fromString(PartitionType *v, String *name);
ACME_API Error PartitionType_asString(PartitionType v, String *out);
//ACME_API Error PartitionType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error PartitionType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API PartitionType_t PartitionType_init(PartitionType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadPartitionType(Unmarshaler *m, PartitionType *v);
ACME_API int marshalerWritePartitionType(Marshaler *m, PartitionType v);
ACME_API bool PartitionType_equal(const PartitionType *a, const PartitionType *b);



typedef struct {
    Bytes data;
} SignatureType_t;

ACME_API uint64_t SignatureType_ID(SignatureType v);
ACME_API Error SignatureType_fromString(SignatureType *v, String *name);
ACME_API Error SignatureType_asString(SignatureType v, String *out);
//ACME_API Error SignatureType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error SignatureType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API SignatureType_t SignatureType_init(SignatureType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadSignatureType(Unmarshaler *m, SignatureType *v);
ACME_API int marshalerWriteSignatureType(Marshaler *m, SignatureType v);
ACME_API bool SignatureType_equal(const SignatureType *a, const SignatureType *b);



typedef struct {
    Bytes data;
} TransactionMax_t;

ACME_API uint64_t TransactionMax_ID(TransactionMax v);
ACME_API Error TransactionMax_fromString(TransactionMax *v, String *name);
ACME_API Error TransactionMax_asString(TransactionMax v, String *out);
//ACME_API Error TransactionMax_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error TransactionMax_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API TransactionMax_t TransactionMax_init(TransactionMax_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadTransactionMax(Unmarshaler *m, TransactionMax *v);
ACME_API int marshalerWriteTransactionMax(Marshaler *m, TransactionMax v);
ACME_API bool TransactionMax_equal(const TransactionMax *a, const TransactionMax *b);



typedef struct {
    Bytes data;
} TransactionType_t;

ACME_API uint64_t TransactionType_ID(TransactionType v);
ACME_API Error TransactionType_fromString(TransactionType *v, String *name);
ACME_API Error TransactionType_asString(TransactionType v, String *out);
//ACME_API Error TransactionType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error TransactionType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API TransactionType_t TransactionType_init(TransactionType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadTransactionType(Unmarshaler *m, TransactionType *v);
ACME_API int marshalerWriteTransactionType(Marshaler *m, TransactionType v);
ACME_API bool TransactionType_equal(const TransactionType *a, const TransactionType *b);



typedef struct {
    Bytes data;
} VoteType_t;

ACME_API uint64_t VoteType_ID(VoteType v);
ACME_API Error VoteType_fromString(VoteType *v, String *name);
ACME_API Error VoteType_asString(VoteType v, String *out);
//ACME_API Error VoteType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error VoteType_unmarshalJSON(Bytes *v, const Marshaler *in);
ACME_API VoteType_t VoteType_init(VoteType_t *v, buffer_t *buffer);
ACME_API int unmarshalerReadVoteType(Unmarshaler *m, VoteType *v);
ACME_API int marshalerWriteVoteType(Marshaler *m, VoteType v);
ACME_API bool VoteType_equal(const VoteType *a, const VoteType *b);



#ifdef __cplusplus
}
#endif
