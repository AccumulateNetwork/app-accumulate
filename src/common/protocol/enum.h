#pragma once

// GENERATED BY go run ./tools/cmd/gen-enum. DO NOT EDIT.

#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif
#include <common/encoding/encoding.h>
#include <common/encoding/marshaler.h>

typedef struct {
   const char *name;
   uint32_t e;
} enum_t;



typedef enum {

    // AccountAuthOperationTypeUnknown is used when the authorization operation is not known.
    AccountAuthOperationTypeUnknown = 0,

    // AccountAuthOperationTypeEnable enables authorization checks for an authority.
    AccountAuthOperationTypeEnable = 1,

    // AccountAuthOperationTypeDisable disables authorization checks for an authority.
    AccountAuthOperationTypeDisable = 2,

    // AccountAuthOperationTypeAddAuthority adds an authority.
    AccountAuthOperationTypeAddAuthority = 3,

    // AccountAuthOperationTypeRemoveAuthority removes an authority.
    AccountAuthOperationTypeRemoveAuthority = 4,

} AccountAuthOperationType;


typedef enum {

    // AccountTypeUnknown represents an unknown account type.
    AccountTypeUnknown = 0,

    // AccountTypeAnchorLedger anchors the other partitions.
    AccountTypeAnchorLedger = 1,

    // AccountTypeIdentity is an Identity account, aka an ADI.
    AccountTypeIdentity = 2,

    // AccountTypeTokenIssuer is a Token Issuer account.
    AccountTypeTokenIssuer = 3,

    // AccountTypeTokenAccount is an ADI Token Account.
    AccountTypeTokenAccount = 4,

    // AccountTypeLiteTokenAccount is a Lite Token Account.
    AccountTypeLiteTokenAccount = 5,

    // AccountTypeBlockLedger is a Block Ledger account.
    AccountTypeBlockLedger = 6,

    // AccountTypeKeyPage is a Key Page account.
    AccountTypeKeyPage = 9,

    // AccountTypeKeyBook is a Key Book account.
    AccountTypeKeyBook = 10,

    // AccountTypeDataAccount is an ADI Data Account.
    AccountTypeDataAccount = 11,

    // AccountTypeLiteDataAccount is a Lite Data Account.
    AccountTypeLiteDataAccount = 12,

    // AccountTypeUnknownSigner represents an unknown signer account.
    AccountTypeUnknownSigner = 13,

    // AccountTypeSystemLedger is a ledger that tracks the state of internal operations.
    AccountTypeSystemLedger = 14,

    // AccountTypeLiteIdentity is a lite identity account.
    AccountTypeLiteIdentity = 15,

    // AccountTypeSyntheticLedger is a ledger that tracks the status of produced and received synthetic transactions.
    AccountTypeSyntheticLedger = 16,

} AccountType;


typedef enum {

    // AllowedTransactionBitUpdateKeyPage is the offset of the UpdateKeyPage bit.
    AllowedTransactionBitUpdateKeyPage = 1,

    // AllowedTransactionBitUpdateAccountAuth is the offset of the UpdateAccountAuth bit.
    AllowedTransactionBitUpdateAccountAuth = 2,

} AllowedTransactionBit;


typedef enum {

    // BookTypeNormal is a normal key book.
    BookTypeNormal = 0,

    // BookTypeValidator is a validator key book.
    BookTypeValidator = 1,

    // BookTypeOperator Operator key book.
    BookTypeOperator = 2,

} BookType;


typedef enum {

    // DataEntryTypeUnknown .
    DataEntryTypeUnknown = 0,

    // DataEntryTypeFactom .
    DataEntryTypeFactom = 1,

    // DataEntryTypeAccumulate .
    DataEntryTypeAccumulate = 2,

} DataEntryType;


typedef enum {

    // KeyPageOperationTypeUnknown is used when the key page operation is not known.
    KeyPageOperationTypeUnknown = 0,

    // KeyPageOperationTypeUpdate replaces a key in the page with a new key.
    KeyPageOperationTypeUpdate = 1,

    // KeyPageOperationTypeRemove removes a key from the page.
    KeyPageOperationTypeRemove = 2,

    // KeyPageOperationTypeAdd adds a key to the page.
    KeyPageOperationTypeAdd = 3,

    // KeyPageOperationTypeSetThreshold sets the signing threshold (the M of "M of N" signatures required).
    KeyPageOperationTypeSetThreshold = 4,

    // KeyPageOperationTypeUpdateAllowed updates the transactions the key page is allowed to execute.
    KeyPageOperationTypeUpdateAllowed = 5,

} KeyPageOperationType;


typedef enum {

    // ObjectTypeUnknown is used when the object type is not known.
    ObjectTypeUnknown = 0,

    // ObjectTypeAccount represents an account object.
    ObjectTypeAccount = 1,

    // ObjectTypeTransaction represents a transaction object.
    ObjectTypeTransaction = 2,

} ObjectType;


typedef enum {

    // PartitionTypeDirectory .
    PartitionTypeDirectory = 1,

    // PartitionTypeBlockValidator .
    PartitionTypeBlockValidator = 2,

} PartitionType;


typedef enum {

    // SignatureTypeUnknown is used when the signature type is not known.
    SignatureTypeUnknown = 0,

    // SignatureTypeLegacyED25519 represents a legacy ED25519 signature.
    SignatureTypeLegacyED25519 = 1,

    // SignatureTypeED25519 represents an ED25519 signature.
    SignatureTypeED25519 = 2,

    // SignatureTypeRCD1 represents an RCD1 signature.
    SignatureTypeRCD1 = 3,

    // SignatureTypeReceipt represents a Merkle tree receipt.
    SignatureTypeReceipt = 4,

    // SignatureTypePartition is used when sending synthetic and system transactions.
    SignatureTypePartition = 5,

    // SignatureTypeSet is used when forwarding multiple signatures.
    SignatureTypeSet = 6,

    // SignatureTypeRemote is used when forwarding a signature from one partition to another.
    SignatureTypeRemote = 7,

    // SignatureTypeBTC represents an BTC signature.
    SignatureTypeBTC = 8,

    // SignatureTypeBTCLegacy represents an BTC signature with uncompressed public key.
    SignatureTypeBTCLegacy = 9,

    // SignatureTypeETH represents an ETH signature.
    SignatureTypeETH = 10,

    // SignatureTypeDelegated represents a signature for a delegated authority.
    SignatureTypeDelegated = 11,

    // SignatureTypeInternal is used for internally produced transactions.
    SignatureTypeInternal = 12,

} SignatureType;


typedef enum {

    // TransactionMaxUser is the highest number reserved for user transactions.
    TransactionMaxUser = 48,

    // TransactionMaxSynthetic is the highest number reserved for synthetic transactions.
    TransactionMaxSynthetic = 95,

    // TransactionMaxSystem is the highest number reserved for internal transactions.
    TransactionMaxSystem = 255,

} TransactionMax;


typedef enum {

    // TransactionTypeUnknown represents an unknown transaction type.
    TransactionTypeUnknown = 0,

    // TransactionTypeCreateIdentity creates an ADI, which produces a synthetic chain.
    TransactionTypeCreateIdentity = 1,

    // TransactionTypeCreateTokenAccount creates an ADI token account, which produces a synthetic chain create transaction.
    TransactionTypeCreateTokenAccount = 2,

    // TransactionTypeSendTokens transfers tokens between token accounts, which produces a synthetic deposit tokens transaction.
    TransactionTypeSendTokens = 3,

    // TransactionTypeCreateDataAccount creates an ADI Data Account, which produces a synthetic chain create transaction.
    TransactionTypeCreateDataAccount = 4,

    // TransactionTypeWriteData writes data to an ADI Data Account, which *does not* produce a synthetic transaction.
    TransactionTypeWriteData = 5,

    // TransactionTypeWriteDataTo writes data to a Lite Data Account, which produces a synthetic write data transaction.
    TransactionTypeWriteDataTo = 6,

    // TransactionTypeAcmeFaucet produces a synthetic deposit tokens transaction that deposits ACME tokens into a lite token account.
    TransactionTypeAcmeFaucet = 7,

    // TransactionTypeCreateToken creates a token issuer, which produces a synthetic chain create transaction.
    TransactionTypeCreateToken = 8,

    // TransactionTypeIssueTokens issues tokens to a token account, which produces a synthetic token deposit transaction.
    TransactionTypeIssueTokens = 9,

    // TransactionTypeBurnTokens burns tokens from a token account, which produces a synthetic burn tokens transaction.
    TransactionTypeBurnTokens = 10,

    // TransactionTypeCreateLiteTokenAccount create a lite token account.
    TransactionTypeCreateLiteTokenAccount = 11,

    // TransactionTypeCreateKeyPage creates a key page, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyPage = 12,

    // TransactionTypeCreateKeyBook creates a key book, which produces a synthetic chain create transaction.
    TransactionTypeCreateKeyBook = 13,

    // TransactionTypeAddCredits converts ACME tokens to credits, which produces a synthetic deposit credits transaction.
    TransactionTypeAddCredits = 14,

    // TransactionTypeUpdateKeyPage adds, removes, or updates keys in a key page, which *does not* produce a synthetic transaction.
    TransactionTypeUpdateKeyPage = 15,

    // TransactionTypeLockAccount sets a major block height that prevents tokens from being transferred out of a lite token account until that height has been reached.
    TransactionTypeLockAccount = 16,

    // TransactionTypeUpdateAccountAuth updates authorization for an account.
    TransactionTypeUpdateAccountAuth = 21,

    // TransactionTypeUpdateKey update key for existing keys.
    TransactionTypeUpdateKey = 22,

    // TransactionTypeRemote is used to sign a remote transaction.
    TransactionTypeRemote = 48,

    // TransactionTypeSyntheticCreateIdentity creates an identity.
    TransactionTypeSyntheticCreateIdentity = 49,

    // TransactionTypeSyntheticWriteData writes data to a data account.
    TransactionTypeSyntheticWriteData = 50,

    // TransactionTypeSyntheticDepositTokens deposits tokens into token accounts.
    TransactionTypeSyntheticDepositTokens = 51,

    // TransactionTypeSyntheticDepositCredits deposits credits into a credit holder.
    TransactionTypeSyntheticDepositCredits = 52,

    // TransactionTypeSyntheticBurnTokens returns tokens to a token issuer's pool of issuable tokens.
    TransactionTypeSyntheticBurnTokens = 53,

    // TransactionTypeSyntheticForwardTransaction forwards a transaction from one partition to another.
    TransactionTypeSyntheticForwardTransaction = 54,

    // TransactionTypeSystemGenesis initializes system chains.
    TransactionTypeSystemGenesis = 96,

    // TransactionTypeDirectoryAnchor anchors one network to another.
    TransactionTypeDirectoryAnchor = 97,

    // TransactionTypeBlockValidatorAnchor system transaction for partition data.
    TransactionTypeBlockValidatorAnchor = 98,

    // TransactionTypeSystemWriteData writes data to a system data account.
    TransactionTypeSystemWriteData = 99,

} TransactionType;


typedef enum {

    // VoteTypeAccept vote yea in favor of proposal.
    VoteTypeAccept = 0,

    // VoteTypeReject vote nay against a proposal.
    VoteTypeReject = 1,

    // VoteTypeAbstain chose not to vote on a proposal.
    VoteTypeAbstain = 2,

    // VoteTypeSuggest put forth a proposal.
    VoteTypeSuggest = 3,

} VoteType;




typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, AccountAuthOperationType *out);
    Error (*set)(struct Bytes *, AccountAuthOperationType in);
} AccountAuthOperationType_t;

ACME_API uint64_t AccountAuthOperationType_ID(AccountAuthOperationType v);
ACME_API Error AccountAuthOperationType_fromString(AccountAuthOperationType *v, String *name);
ACME_API Error AccountAuthOperationType_asString(AccountAuthOperationType v, String *out);
//ACME_API Error AccountAuthOperationType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AccountAuthOperationType_unmarshalJSON(Bytes *v, const Marshaler *in);
AccountAuthOperationType_t AccountAuthOperationType_init(AccountAuthOperationType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error AccountAuthOperationType_set(VarInt *v, AccountAuthOperationType n) {
    return VarInt_set(v,n);
}

ACME_API Error AccountAuthOperationType_get(const VarInt *v, AccountAuthOperationType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Account Auth Operation Type
ACME_API uint64_t AccountAuthOperationType_ID(AccountAuthOperationType v) { return (uint64_t)(v); }

// String returns the name of the Account Auth Operation Type
static enum_t AccountAuthOperationType_l[] = {
	{ "unknown", AccountAuthOperationTypeUnknown },
	{ "enable", AccountAuthOperationTypeEnable },
	{ "disable", AccountAuthOperationTypeDisable },
	{ "addauthority", AccountAuthOperationTypeAddAuthority },
	{ "removeauthority", AccountAuthOperationTypeRemoveAuthority },
	{ 0,0 },
};

ACME_API Error AccountAuthOperationType_asString(const AccountAuthOperationType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountAuthOperationType_l[i].name == 0 ) {
            break;
        }
        if ( AccountAuthOperationType_l[i].e == v ) {
            String_set(out, AccountAuthOperationType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AccountAuthOperationTypeByName returns the named Account Auth Operation Type.
ACME_API Error AccountAuthOperationType_fromString(AccountAuthOperationType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountAuthOperationType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(AccountAuthOperationType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = AccountAuthOperationType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AccountAuthOperationType_marshalJSON marshals the Account Auth Operation Type to JSON as a string.
//ACME_API Error AccountAuthOperationType_marshalJSON(const AccountAuthOperationType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = AccountAuthOperationType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = AccountAuthOperationType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// AccountAuthOperationType_unmarshalJSON unmarshals the Account Auth Operation Type from JSON as a string.
//ACME_API Error AccountAuthOperationType_unmarshalJSON(AccountAuthOperationType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = AccountAuthOperationType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return AccountAuthOperationType_fromString(v, &s);
//}

// MarshalBinary marshals the Account Auth Operation Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteAccountAuthOperationType(Marshaler *m, AccountAuthOperationType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Account Auth Operation Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadAccountAuthOperationType(Marshaler *m, AccountAuthOperationType *v) {
//	return unmarshalerReadField(m, v);
//}

// AccountAuthOperationType_binarySize returns the number of bytes required to binary marshal the Account Auth Operation Type.
//AccountAuthOperationType_t AccountAuthOperationType_init(AccountAuthOperationType_t *v, buffer_t *buffer) {
//    AccountAuthOperationType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    AccountAuthOperationType_marshalBinary,
//                    AccountAuthOperationType_unmarshalBinary,
//                    AccountAuthOperationType_marshalJSON,
//                    AccountAuthOperationType_unmarshalJSON},
//                    AccountAuthOperationType_get,
//                    AccountAuthOperationType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(AccountAuthOperationType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, AccountType *out);
    Error (*set)(struct Bytes *, AccountType in);
} AccountType_t;

ACME_API uint64_t AccountType_ID(AccountType v);
ACME_API Error AccountType_fromString(AccountType *v, String *name);
ACME_API Error AccountType_asString(AccountType v, String *out);
//ACME_API Error AccountType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AccountType_unmarshalJSON(Bytes *v, const Marshaler *in);
AccountType_t AccountType_init(AccountType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error AccountType_set(VarInt *v, AccountType n) {
    return VarInt_set(v,n);
}

ACME_API Error AccountType_get(const VarInt *v, AccountType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Account Type
ACME_API uint64_t AccountType_ID(AccountType v) { return (uint64_t)(v); }

// String returns the name of the Account Type
static enum_t AccountType_l[] = {
	{ "unknown", AccountTypeUnknown },
	{ "anchorledger", AccountTypeAnchorLedger },
	{ "identity", AccountTypeIdentity },
	{ "tokenissuer", AccountTypeTokenIssuer },
	{ "tokenaccount", AccountTypeTokenAccount },
	{ "litetokenaccount", AccountTypeLiteTokenAccount },
	{ "blockledger", AccountTypeBlockLedger },
	{ "keypage", AccountTypeKeyPage },
	{ "keybook", AccountTypeKeyBook },
	{ "dataaccount", AccountTypeDataAccount },
	{ "litedataaccount", AccountTypeLiteDataAccount },
	{ "unknownsigner", AccountTypeUnknownSigner },
	{ "systemledger", AccountTypeSystemLedger },
	{ "liteidentity", AccountTypeLiteIdentity },
	{ "syntheticledger", AccountTypeSyntheticLedger },
	{ 0,0 },
};

ACME_API Error AccountType_asString(const AccountType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountType_l[i].name == 0 ) {
            break;
        }
        if ( AccountType_l[i].e == v ) {
            String_set(out, AccountType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AccountTypeByName returns the named Account Type.
ACME_API Error AccountType_fromString(AccountType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AccountType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(AccountType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = AccountType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AccountType_marshalJSON marshals the Account Type to JSON as a string.
//ACME_API Error AccountType_marshalJSON(const AccountType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = AccountType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = AccountType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// AccountType_unmarshalJSON unmarshals the Account Type from JSON as a string.
//ACME_API Error AccountType_unmarshalJSON(AccountType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = AccountType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return AccountType_fromString(v, &s);
//}

// MarshalBinary marshals the Account Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteAccountType(Marshaler *m, AccountType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Account Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadAccountType(Marshaler *m, AccountType *v) {
//	return unmarshalerReadField(m, v);
//}

// AccountType_binarySize returns the number of bytes required to binary marshal the Account Type.
//AccountType_t AccountType_init(AccountType_t *v, buffer_t *buffer) {
//    AccountType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    AccountType_marshalBinary,
//                    AccountType_unmarshalBinary,
//                    AccountType_marshalJSON,
//                    AccountType_unmarshalJSON},
//                    AccountType_get,
//                    AccountType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(AccountType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, AllowedTransactionBit *out);
    Error (*set)(struct Bytes *, AllowedTransactionBit in);
} AllowedTransactionBit_t;

ACME_API uint64_t AllowedTransactionBit_ID(AllowedTransactionBit v);
ACME_API Error AllowedTransactionBit_fromString(AllowedTransactionBit *v, String *name);
ACME_API Error AllowedTransactionBit_asString(AllowedTransactionBit v, String *out);
//ACME_API Error AllowedTransactionBit_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error AllowedTransactionBit_unmarshalJSON(Bytes *v, const Marshaler *in);
AllowedTransactionBit_t AllowedTransactionBit_init(AllowedTransactionBit_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error AllowedTransactionBit_set(VarInt *v, AllowedTransactionBit n) {
    return VarInt_set(v,n);
}

ACME_API Error AllowedTransactionBit_get(const VarInt *v, AllowedTransactionBit *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Allowed Transaction Bit
ACME_API uint64_t AllowedTransactionBit_ID(AllowedTransactionBit v) { return (uint64_t)(v); }

// String returns the name of the Allowed Transaction Bit
static enum_t AllowedTransactionBit_l[] = {
	{ "updatekeypage", AllowedTransactionBitUpdateKeyPage },
	{ "updateaccountauth", AllowedTransactionBitUpdateAccountAuth },
	{ 0,0 },
};

ACME_API Error AllowedTransactionBit_asString(const AllowedTransactionBit v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AllowedTransactionBit_l[i].name == 0 ) {
            break;
        }
        if ( AllowedTransactionBit_l[i].e == v ) {
            String_set(out, AllowedTransactionBit_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AllowedTransactionBitByName returns the named Allowed Transaction Bit.
ACME_API Error AllowedTransactionBit_fromString(AllowedTransactionBit *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( AllowedTransactionBit_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(AllowedTransactionBit_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = AllowedTransactionBit_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// AllowedTransactionBit_marshalJSON marshals the Allowed Transaction Bit to JSON as a string.
//ACME_API Error AllowedTransactionBit_marshalJSON(const AllowedTransactionBit_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = AllowedTransactionBit_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = AllowedTransactionBit_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// AllowedTransactionBit_unmarshalJSON unmarshals the Allowed Transaction Bit from JSON as a string.
//ACME_API Error AllowedTransactionBit_unmarshalJSON(AllowedTransactionBit_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = AllowedTransactionBit_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return AllowedTransactionBit_fromString(v, &s);
//}

// MarshalBinary marshals the Allowed Transaction Bit to bytes as a unsigned varint.
//ACME_API int marshalerWriteAllowedTransactionBit(Marshaler *m, AllowedTransactionBit v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Allowed Transaction Bit from bytes as a unsigned varint.
//ACME_API int unmarshalerReadAllowedTransactionBit(Marshaler *m, AllowedTransactionBit *v) {
//	return unmarshalerReadField(m, v);
//}

// AllowedTransactionBit_binarySize returns the number of bytes required to binary marshal the Allowed Transaction Bit.
//AllowedTransactionBit_t AllowedTransactionBit_init(AllowedTransactionBit_t *v, buffer_t *buffer) {
//    AllowedTransactionBit_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    AllowedTransactionBit_marshalBinary,
//                    AllowedTransactionBit_unmarshalBinary,
//                    AllowedTransactionBit_marshalJSON,
//                    AllowedTransactionBit_unmarshalJSON},
//                    AllowedTransactionBit_get,
//                    AllowedTransactionBit_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(AllowedTransactionBit);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, BookType *out);
    Error (*set)(struct Bytes *, BookType in);
} BookType_t;

ACME_API uint64_t BookType_ID(BookType v);
ACME_API Error BookType_fromString(BookType *v, String *name);
ACME_API Error BookType_asString(BookType v, String *out);
//ACME_API Error BookType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error BookType_unmarshalJSON(Bytes *v, const Marshaler *in);
BookType_t BookType_init(BookType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error BookType_set(VarInt *v, BookType n) {
    return VarInt_set(v,n);
}

ACME_API Error BookType_get(const VarInt *v, BookType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Book Type
ACME_API uint64_t BookType_ID(BookType v) { return (uint64_t)(v); }

// String returns the name of the Book Type
static enum_t BookType_l[] = {
	{ "normal", BookTypeNormal },
	{ "validator", BookTypeValidator },
	{ "operator", BookTypeOperator },
	{ 0,0 },
};

ACME_API Error BookType_asString(const BookType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( BookType_l[i].name == 0 ) {
            break;
        }
        if ( BookType_l[i].e == v ) {
            String_set(out, BookType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// BookTypeByName returns the named Book Type.
ACME_API Error BookType_fromString(BookType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( BookType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(BookType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = BookType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// BookType_marshalJSON marshals the Book Type to JSON as a string.
//ACME_API Error BookType_marshalJSON(const BookType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = BookType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = BookType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// BookType_unmarshalJSON unmarshals the Book Type from JSON as a string.
//ACME_API Error BookType_unmarshalJSON(BookType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = BookType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return BookType_fromString(v, &s);
//}

// MarshalBinary marshals the Book Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteBookType(Marshaler *m, BookType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Book Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadBookType(Marshaler *m, BookType *v) {
//	return unmarshalerReadField(m, v);
//}

// BookType_binarySize returns the number of bytes required to binary marshal the Book Type.
//BookType_t BookType_init(BookType_t *v, buffer_t *buffer) {
//    BookType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    BookType_marshalBinary,
//                    BookType_unmarshalBinary,
//                    BookType_marshalJSON,
//                    BookType_unmarshalJSON},
//                    BookType_get,
//                    BookType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(BookType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, DataEntryType *out);
    Error (*set)(struct Bytes *, DataEntryType in);
} DataEntryType_t;

ACME_API uint64_t DataEntryType_ID(DataEntryType v);
ACME_API Error DataEntryType_fromString(DataEntryType *v, String *name);
ACME_API Error DataEntryType_asString(DataEntryType v, String *out);
//ACME_API Error DataEntryType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error DataEntryType_unmarshalJSON(Bytes *v, const Marshaler *in);
DataEntryType_t DataEntryType_init(DataEntryType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error DataEntryType_set(VarInt *v, DataEntryType n) {
    return VarInt_set(v,n);
}

ACME_API Error DataEntryType_get(const VarInt *v, DataEntryType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Data Entry Type
ACME_API uint64_t DataEntryType_ID(DataEntryType v) { return (uint64_t)(v); }

// String returns the name of the Data Entry Type
static enum_t DataEntryType_l[] = {
	{ "unknown", DataEntryTypeUnknown },
	{ "factom", DataEntryTypeFactom },
	{ "accumulate", DataEntryTypeAccumulate },
	{ 0,0 },
};

ACME_API Error DataEntryType_asString(const DataEntryType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( DataEntryType_l[i].name == 0 ) {
            break;
        }
        if ( DataEntryType_l[i].e == v ) {
            String_set(out, DataEntryType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// DataEntryTypeByName returns the named Data Entry Type.
ACME_API Error DataEntryType_fromString(DataEntryType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( DataEntryType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(DataEntryType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = DataEntryType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// DataEntryType_marshalJSON marshals the Data Entry Type to JSON as a string.
//ACME_API Error DataEntryType_marshalJSON(const DataEntryType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = DataEntryType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = DataEntryType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// DataEntryType_unmarshalJSON unmarshals the Data Entry Type from JSON as a string.
//ACME_API Error DataEntryType_unmarshalJSON(DataEntryType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = DataEntryType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return DataEntryType_fromString(v, &s);
//}

// MarshalBinary marshals the Data Entry Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteDataEntryType(Marshaler *m, DataEntryType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Data Entry Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadDataEntryType(Marshaler *m, DataEntryType *v) {
//	return unmarshalerReadField(m, v);
//}

// DataEntryType_binarySize returns the number of bytes required to binary marshal the Data Entry Type.
//DataEntryType_t DataEntryType_init(DataEntryType_t *v, buffer_t *buffer) {
//    DataEntryType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    DataEntryType_marshalBinary,
//                    DataEntryType_unmarshalBinary,
//                    DataEntryType_marshalJSON,
//                    DataEntryType_unmarshalJSON},
//                    DataEntryType_get,
//                    DataEntryType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(DataEntryType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, KeyPageOperationType *out);
    Error (*set)(struct Bytes *, KeyPageOperationType in);
} KeyPageOperationType_t;

ACME_API uint64_t KeyPageOperationType_ID(KeyPageOperationType v);
ACME_API Error KeyPageOperationType_fromString(KeyPageOperationType *v, String *name);
ACME_API Error KeyPageOperationType_asString(KeyPageOperationType v, String *out);
//ACME_API Error KeyPageOperationType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error KeyPageOperationType_unmarshalJSON(Bytes *v, const Marshaler *in);
KeyPageOperationType_t KeyPageOperationType_init(KeyPageOperationType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error KeyPageOperationType_set(VarInt *v, KeyPageOperationType n) {
    return VarInt_set(v,n);
}

ACME_API Error KeyPageOperationType_get(const VarInt *v, KeyPageOperationType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Key Page Operation Type
ACME_API uint64_t KeyPageOperationType_ID(KeyPageOperationType v) { return (uint64_t)(v); }

// String returns the name of the Key Page Operation Type
static enum_t KeyPageOperationType_l[] = {
	{ "unknown", KeyPageOperationTypeUnknown },
	{ "update", KeyPageOperationTypeUpdate },
	{ "remove", KeyPageOperationTypeRemove },
	{ "add", KeyPageOperationTypeAdd },
	{ "setthreshold", KeyPageOperationTypeSetThreshold },
	{ "updateallowed", KeyPageOperationTypeUpdateAllowed },
	{ 0,0 },
};

ACME_API Error KeyPageOperationType_asString(const KeyPageOperationType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( KeyPageOperationType_l[i].name == 0 ) {
            break;
        }
        if ( KeyPageOperationType_l[i].e == v ) {
            String_set(out, KeyPageOperationType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// KeyPageOperationTypeByName returns the named Key Page Operation Type.
ACME_API Error KeyPageOperationType_fromString(KeyPageOperationType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( KeyPageOperationType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(KeyPageOperationType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = KeyPageOperationType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// KeyPageOperationType_marshalJSON marshals the Key Page Operation Type to JSON as a string.
//ACME_API Error KeyPageOperationType_marshalJSON(const KeyPageOperationType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = KeyPageOperationType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = KeyPageOperationType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// KeyPageOperationType_unmarshalJSON unmarshals the Key Page Operation Type from JSON as a string.
//ACME_API Error KeyPageOperationType_unmarshalJSON(KeyPageOperationType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = KeyPageOperationType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return KeyPageOperationType_fromString(v, &s);
//}

// MarshalBinary marshals the Key Page Operation Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteKeyPageOperationType(Marshaler *m, KeyPageOperationType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Key Page Operation Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadKeyPageOperationType(Marshaler *m, KeyPageOperationType *v) {
//	return unmarshalerReadField(m, v);
//}

// KeyPageOperationType_binarySize returns the number of bytes required to binary marshal the Key Page Operation Type.
//KeyPageOperationType_t KeyPageOperationType_init(KeyPageOperationType_t *v, buffer_t *buffer) {
//    KeyPageOperationType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    KeyPageOperationType_marshalBinary,
//                    KeyPageOperationType_unmarshalBinary,
//                    KeyPageOperationType_marshalJSON,
//                    KeyPageOperationType_unmarshalJSON},
//                    KeyPageOperationType_get,
//                    KeyPageOperationType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(KeyPageOperationType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, ObjectType *out);
    Error (*set)(struct Bytes *, ObjectType in);
} ObjectType_t;

ACME_API uint64_t ObjectType_ID(ObjectType v);
ACME_API Error ObjectType_fromString(ObjectType *v, String *name);
ACME_API Error ObjectType_asString(ObjectType v, String *out);
//ACME_API Error ObjectType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error ObjectType_unmarshalJSON(Bytes *v, const Marshaler *in);
ObjectType_t ObjectType_init(ObjectType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error ObjectType_set(VarInt *v, ObjectType n) {
    return VarInt_set(v,n);
}

ACME_API Error ObjectType_get(const VarInt *v, ObjectType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Object Type
ACME_API uint64_t ObjectType_ID(ObjectType v) { return (uint64_t)(v); }

// String returns the name of the Object Type
static enum_t ObjectType_l[] = {
	{ "unknown", ObjectTypeUnknown },
	{ "account", ObjectTypeAccount },
	{ "transaction", ObjectTypeTransaction },
	{ 0,0 },
};

ACME_API Error ObjectType_asString(const ObjectType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( ObjectType_l[i].name == 0 ) {
            break;
        }
        if ( ObjectType_l[i].e == v ) {
            String_set(out, ObjectType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// ObjectTypeByName returns the named Object Type.
ACME_API Error ObjectType_fromString(ObjectType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( ObjectType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(ObjectType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = ObjectType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// ObjectType_marshalJSON marshals the Object Type to JSON as a string.
//ACME_API Error ObjectType_marshalJSON(const ObjectType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = ObjectType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = ObjectType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// ObjectType_unmarshalJSON unmarshals the Object Type from JSON as a string.
//ACME_API Error ObjectType_unmarshalJSON(ObjectType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = ObjectType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return ObjectType_fromString(v, &s);
//}

// MarshalBinary marshals the Object Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteObjectType(Marshaler *m, ObjectType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Object Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadObjectType(Marshaler *m, ObjectType *v) {
//	return unmarshalerReadField(m, v);
//}

// ObjectType_binarySize returns the number of bytes required to binary marshal the Object Type.
//ObjectType_t ObjectType_init(ObjectType_t *v, buffer_t *buffer) {
//    ObjectType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    ObjectType_marshalBinary,
//                    ObjectType_unmarshalBinary,
//                    ObjectType_marshalJSON,
//                    ObjectType_unmarshalJSON},
//                    ObjectType_get,
//                    ObjectType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(ObjectType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, PartitionType *out);
    Error (*set)(struct Bytes *, PartitionType in);
} PartitionType_t;

ACME_API uint64_t PartitionType_ID(PartitionType v);
ACME_API Error PartitionType_fromString(PartitionType *v, String *name);
ACME_API Error PartitionType_asString(PartitionType v, String *out);
//ACME_API Error PartitionType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error PartitionType_unmarshalJSON(Bytes *v, const Marshaler *in);
PartitionType_t PartitionType_init(PartitionType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error PartitionType_set(VarInt *v, PartitionType n) {
    return VarInt_set(v,n);
}

ACME_API Error PartitionType_get(const VarInt *v, PartitionType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Partition Type
ACME_API uint64_t PartitionType_ID(PartitionType v) { return (uint64_t)(v); }

// String returns the name of the Partition Type
static enum_t PartitionType_l[] = {
	{ "directory", PartitionTypeDirectory },
	{ "blockvalidator", PartitionTypeBlockValidator },
	{ 0,0 },
};

ACME_API Error PartitionType_asString(const PartitionType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( PartitionType_l[i].name == 0 ) {
            break;
        }
        if ( PartitionType_l[i].e == v ) {
            String_set(out, PartitionType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// PartitionTypeByName returns the named Partition Type.
ACME_API Error PartitionType_fromString(PartitionType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( PartitionType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(PartitionType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = PartitionType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// PartitionType_marshalJSON marshals the Partition Type to JSON as a string.
//ACME_API Error PartitionType_marshalJSON(const PartitionType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = PartitionType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = PartitionType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// PartitionType_unmarshalJSON unmarshals the Partition Type from JSON as a string.
//ACME_API Error PartitionType_unmarshalJSON(PartitionType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = PartitionType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return PartitionType_fromString(v, &s);
//}

// MarshalBinary marshals the Partition Type to bytes as a unsigned varint.
//ACME_API int marshalerWritePartitionType(Marshaler *m, PartitionType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Partition Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadPartitionType(Marshaler *m, PartitionType *v) {
//	return unmarshalerReadField(m, v);
//}

// PartitionType_binarySize returns the number of bytes required to binary marshal the Partition Type.
//PartitionType_t PartitionType_init(PartitionType_t *v, buffer_t *buffer) {
//    PartitionType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    PartitionType_marshalBinary,
//                    PartitionType_unmarshalBinary,
//                    PartitionType_marshalJSON,
//                    PartitionType_unmarshalJSON},
//                    PartitionType_get,
//                    PartitionType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(PartitionType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, SignatureType *out);
    Error (*set)(struct Bytes *, SignatureType in);
} SignatureType_t;

ACME_API uint64_t SignatureType_ID(SignatureType v);
ACME_API Error SignatureType_fromString(SignatureType *v, String *name);
ACME_API Error SignatureType_asString(SignatureType v, String *out);
//ACME_API Error SignatureType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error SignatureType_unmarshalJSON(Bytes *v, const Marshaler *in);
SignatureType_t SignatureType_init(SignatureType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error SignatureType_set(VarInt *v, SignatureType n) {
    return VarInt_set(v,n);
}

ACME_API Error SignatureType_get(const VarInt *v, SignatureType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Signature Type
ACME_API uint64_t SignatureType_ID(SignatureType v) { return (uint64_t)(v); }

// String returns the name of the Signature Type
static enum_t SignatureType_l[] = {
	{ "unknown", SignatureTypeUnknown },
	{ "legacyed25519", SignatureTypeLegacyED25519 },
	{ "ed25519", SignatureTypeED25519 },
	{ "rcd1", SignatureTypeRCD1 },
	{ "receipt", SignatureTypeReceipt },
	{ "partition", SignatureTypePartition },
	{ "set", SignatureTypeSet },
	{ "remote", SignatureTypeRemote },
	{ "btc", SignatureTypeBTC },
	{ "btclegacy", SignatureTypeBTCLegacy },
	{ "eth", SignatureTypeETH },
	{ "delegated", SignatureTypeDelegated },
	{ "internal", SignatureTypeInternal },
	{ 0,0 },
};

ACME_API Error SignatureType_asString(const SignatureType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( SignatureType_l[i].name == 0 ) {
            break;
        }
        if ( SignatureType_l[i].e == v ) {
            String_set(out, SignatureType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// SignatureTypeByName returns the named Signature Type.
ACME_API Error SignatureType_fromString(SignatureType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( SignatureType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(SignatureType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = SignatureType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// SignatureType_marshalJSON marshals the Signature Type to JSON as a string.
//ACME_API Error SignatureType_marshalJSON(const SignatureType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = SignatureType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = SignatureType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// SignatureType_unmarshalJSON unmarshals the Signature Type from JSON as a string.
//ACME_API Error SignatureType_unmarshalJSON(SignatureType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = SignatureType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return SignatureType_fromString(v, &s);
//}

// MarshalBinary marshals the Signature Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteSignatureType(Marshaler *m, SignatureType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Signature Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadSignatureType(Marshaler *m, SignatureType *v) {
//	return unmarshalerReadField(m, v);
//}

// SignatureType_binarySize returns the number of bytes required to binary marshal the Signature Type.
//SignatureType_t SignatureType_init(SignatureType_t *v, buffer_t *buffer) {
//    SignatureType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    SignatureType_marshalBinary,
//                    SignatureType_unmarshalBinary,
//                    SignatureType_marshalJSON,
//                    SignatureType_unmarshalJSON},
//                    SignatureType_get,
//                    SignatureType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(SignatureType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, TransactionMax *out);
    Error (*set)(struct Bytes *, TransactionMax in);
} TransactionMax_t;

ACME_API uint64_t TransactionMax_ID(TransactionMax v);
ACME_API Error TransactionMax_fromString(TransactionMax *v, String *name);
ACME_API Error TransactionMax_asString(TransactionMax v, String *out);
//ACME_API Error TransactionMax_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error TransactionMax_unmarshalJSON(Bytes *v, const Marshaler *in);
TransactionMax_t TransactionMax_init(TransactionMax_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error TransactionMax_set(VarInt *v, TransactionMax n) {
    return VarInt_set(v,n);
}

ACME_API Error TransactionMax_get(const VarInt *v, TransactionMax *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Transaction Max
ACME_API uint64_t TransactionMax_ID(TransactionMax v) { return (uint64_t)(v); }

// String returns the name of the Transaction Max
static enum_t TransactionMax_l[] = {
	{ "user", TransactionMaxUser },
	{ "synthetic", TransactionMaxSynthetic },
	{ "system", TransactionMaxSystem },
	{ 0,0 },
};

ACME_API Error TransactionMax_asString(const TransactionMax v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionMax_l[i].name == 0 ) {
            break;
        }
        if ( TransactionMax_l[i].e == v ) {
            String_set(out, TransactionMax_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// TransactionMaxByName returns the named Transaction Max.
ACME_API Error TransactionMax_fromString(TransactionMax *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionMax_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(TransactionMax_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = TransactionMax_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// TransactionMax_marshalJSON marshals the Transaction Max to JSON as a string.
//ACME_API Error TransactionMax_marshalJSON(const TransactionMax_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = TransactionMax_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = TransactionMax_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// TransactionMax_unmarshalJSON unmarshals the Transaction Max from JSON as a string.
//ACME_API Error TransactionMax_unmarshalJSON(TransactionMax_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = TransactionMax_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return TransactionMax_fromString(v, &s);
//}

// MarshalBinary marshals the Transaction Max to bytes as a unsigned varint.
//ACME_API int marshalerWriteTransactionMax(Marshaler *m, TransactionMax v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Transaction Max from bytes as a unsigned varint.
//ACME_API int unmarshalerReadTransactionMax(Marshaler *m, TransactionMax *v) {
//	return unmarshalerReadField(m, v);
//}

// TransactionMax_binarySize returns the number of bytes required to binary marshal the Transaction Max.
//TransactionMax_t TransactionMax_init(TransactionMax_t *v, buffer_t *buffer) {
//    TransactionMax_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    TransactionMax_marshalBinary,
//                    TransactionMax_unmarshalBinary,
//                    TransactionMax_marshalJSON,
//                    TransactionMax_unmarshalJSON},
//                    TransactionMax_get,
//                    TransactionMax_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(TransactionMax);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, TransactionType *out);
    Error (*set)(struct Bytes *, TransactionType in);
} TransactionType_t;

ACME_API uint64_t TransactionType_ID(TransactionType v);
ACME_API Error TransactionType_fromString(TransactionType *v, String *name);
ACME_API Error TransactionType_asString(TransactionType v, String *out);
//ACME_API Error TransactionType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error TransactionType_unmarshalJSON(Bytes *v, const Marshaler *in);
TransactionType_t TransactionType_init(TransactionType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error TransactionType_set(VarInt *v, TransactionType n) {
    return VarInt_set(v,n);
}

ACME_API Error TransactionType_get(const VarInt *v, TransactionType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Transaction Type
ACME_API uint64_t TransactionType_ID(TransactionType v) { return (uint64_t)(v); }

// String returns the name of the Transaction Type
static enum_t TransactionType_l[] = {
	{ "unknown", TransactionTypeUnknown },
	{ "createidentity", TransactionTypeCreateIdentity },
	{ "createtokenaccount", TransactionTypeCreateTokenAccount },
	{ "sendtokens", TransactionTypeSendTokens },
	{ "createdataaccount", TransactionTypeCreateDataAccount },
	{ "writedata", TransactionTypeWriteData },
	{ "writedatato", TransactionTypeWriteDataTo },
	{ "acmefaucet", TransactionTypeAcmeFaucet },
	{ "createtoken", TransactionTypeCreateToken },
	{ "issuetokens", TransactionTypeIssueTokens },
	{ "burntokens", TransactionTypeBurnTokens },
	{ "createlitetokenaccount", TransactionTypeCreateLiteTokenAccount },
	{ "createkeypage", TransactionTypeCreateKeyPage },
	{ "createkeybook", TransactionTypeCreateKeyBook },
	{ "addcredits", TransactionTypeAddCredits },
	{ "updatekeypage", TransactionTypeUpdateKeyPage },
	{ "lockaccount", TransactionTypeLockAccount },
	{ "updateaccountauth", TransactionTypeUpdateAccountAuth },
	{ "updatekey", TransactionTypeUpdateKey },
	{ "remote", TransactionTypeRemote },
	{ "syntheticcreateidentity", TransactionTypeSyntheticCreateIdentity },
	{ "syntheticwritedata", TransactionTypeSyntheticWriteData },
	{ "syntheticdeposittokens", TransactionTypeSyntheticDepositTokens },
	{ "syntheticdepositcredits", TransactionTypeSyntheticDepositCredits },
	{ "syntheticburntokens", TransactionTypeSyntheticBurnTokens },
	{ "syntheticforwardtransaction", TransactionTypeSyntheticForwardTransaction },
	{ "systemgenesis", TransactionTypeSystemGenesis },
	{ "directoryanchor", TransactionTypeDirectoryAnchor },
	{ "blockvalidatoranchor", TransactionTypeBlockValidatorAnchor },
	{ "systemwritedata", TransactionTypeSystemWriteData },
	{ 0,0 },
};

ACME_API Error TransactionType_asString(const TransactionType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionType_l[i].name == 0 ) {
            break;
        }
        if ( TransactionType_l[i].e == v ) {
            String_set(out, TransactionType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// TransactionTypeByName returns the named Transaction Type.
ACME_API Error TransactionType_fromString(TransactionType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( TransactionType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(TransactionType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = TransactionType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// TransactionType_marshalJSON marshals the Transaction Type to JSON as a string.
//ACME_API Error TransactionType_marshalJSON(const TransactionType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = TransactionType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = TransactionType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// TransactionType_unmarshalJSON unmarshals the Transaction Type from JSON as a string.
//ACME_API Error TransactionType_unmarshalJSON(TransactionType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = TransactionType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return TransactionType_fromString(v, &s);
//}

// MarshalBinary marshals the Transaction Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteTransactionType(Marshaler *m, TransactionType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Transaction Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadTransactionType(Marshaler *m, TransactionType *v) {
//	return unmarshalerReadField(m, v);
//}

// TransactionType_binarySize returns the number of bytes required to binary marshal the Transaction Type.
//TransactionType_t TransactionType_init(TransactionType_t *v, buffer_t *buffer) {
//    TransactionType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    TransactionType_marshalBinary,
//                    TransactionType_unmarshalBinary,
//                    TransactionType_marshalJSON,
//                    TransactionType_unmarshalJSON},
//                    TransactionType_get,
//                    TransactionType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(TransactionType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif



typedef struct {
    Bytes data;
    Error (*get)(const struct Bytes *, VoteType *out);
    Error (*set)(struct Bytes *, VoteType in);
} VoteType_t;

ACME_API uint64_t VoteType_ID(VoteType v);
ACME_API Error VoteType_fromString(VoteType *v, String *name);
ACME_API Error VoteType_asString(VoteType v, String *out);
//ACME_API Error VoteType_marshalJSON(const Bytes *v, Marshaler *out);
//ACME_API Error VoteType_unmarshalJSON(Bytes *v, const Marshaler *in);
VoteType_t VoteType_init(VoteType_t *v, buffer_t *buffer);

#ifndef ACME_HEADER


ACME_API Error VoteType_set(VarInt *v, VoteType n) {
    return VarInt_set(v,n);
}

ACME_API Error VoteType_get(const VarInt *v, VoteType *n) {
    return VarInt_get(v,(int64_t*)n);
}


// ID returns the ID of the Vote Type
ACME_API uint64_t VoteType_ID(VoteType v) { return (uint64_t)(v); }

// String returns the name of the Vote Type
static enum_t VoteType_l[] = {
	{ "accept", VoteTypeAccept },
	{ "reject", VoteTypeReject },
	{ "abstain", VoteTypeAbstain },
	{ "suggest", VoteTypeSuggest },
	{ 0,0 },
};

ACME_API Error VoteType_asString(const VoteType v, String *out) {
    CHECK_ERROR(out)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( VoteType_l[i].name == 0 ) {
            break;
        }
        if ( VoteType_l[i].e == v ) {
            String_set(out, VoteType_l[i].name);
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// VoteTypeByName returns the named Vote Type.
ACME_API Error VoteType_fromString(VoteType *v, String *name) {
    CHECK_ERROR(name)
    //since we are only dealing with a limited number of enumerations, we will do a linear search
    for ( uint64_t i = 0; ; ++i ) {
        if ( VoteType_l[i].name == 0 ) {
            break;
        }
        if ( strncmp(VoteType_l[i].name, (const char*)name->data.buffer.ptr+name->data.buffer.offset,name->data.buffer.size) == 0 ) {
            *v = VoteType_l[i].e;
            return ErrorCode(ErrorNone);
        }
    }
    return ErrorCode(ErrorTypeNotFound);
}

// VoteType_marshalJSON marshals the Vote Type to JSON as a string.
//ACME_API Error VoteType_marshalJSON(const VoteType_t *v, Marshaler *out) {
//    CHECK_ERROR(out)
//
//    Error e = VoteType_valid(v);
//   if ( IsError(e) ) {
//        return e;
//    }
//
//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_init(0, &buffer, sizeof(data));
//    e = VoteType_asString(v, &s);
//    if ( IsError(e) ) {
//        return e;
//    }
//    return String_marshalJSON(&s, out);
//}

// VoteType_unmarshalJSON unmarshals the Vote Type from JSON as a string.
//ACME_API Error VoteType_unmarshalJSON(VoteType_t *v, const Marshaler *in) {
//    CHECK_ERROR(v)
//    CHECK_ERROR(in)

//    Error e = VoteType_valid(v);
//    if (e.code != ErrorNone) {
//        return e;
//    }

//    uint8_t data[32] = {0};
//    buffer_t buffer = {data, sizeof(data), 0};
//    String s = String_new(&buffer, sizeof(data));
//    //unmarshal the "in" buffer from the Marshaler into a String
//    e = s.data.UnmarshalJSON(&s.data, in);
//    if ( e.code != ErrorNone ) {
//        return e;
//    }
//    //now convert the unmarshaled string into the enum
//    return VoteType_fromString(v, &s);
//}

// MarshalBinary marshals the Vote Type to bytes as a unsigned varint.
//ACME_API int marshalerWriteVoteType(Marshaler *m, VoteType v) {
//    return marshalerWriteField(m, v);
//}


// UnmarshalBinary unmarshals the Vote Type from bytes as a unsigned varint.
//ACME_API int unmarshalerReadVoteType(Marshaler *m, VoteType *v) {
//	return unmarshalerReadField(m, v);
//}

// VoteType_binarySize returns the number of bytes required to binary marshal the Vote Type.
//VoteType_t VoteType_init(VoteType_t *v, buffer_t *buffer) {
//    VoteType_t init = { { {0,0,0},
//                    VarInt_binarySize,
//                    Bytes_equal,
//                    Bytes_copy,
//                    VoteType_marshalBinary,
//                    VoteType_unmarshalBinary,
//                    VoteType_marshalJSON,
//                    VoteType_unmarshalJSON},
//                    VoteType_get,
//                    VoteType_set,
//                  };
//    if (buffer) {
//        int sizeNeeded = sizeof(VoteType);
//        if ( buffer->size - buffer->offset < sizeNeeded ) {
//            return init;
//        }
//        init.data.buffer.ptr = buffer->ptr;
//        init.data.buffer.offset = buffer->offset;
//        init.data.buffer.size = sizeNeeded;
//        buffer->offset += sizeNeeded;
//    }
//
//    if (v) {
//        *v = init;
//    }
//    return init;
//}
#endif /* !ACME_HEADER */

#ifdef __cplusplus
}
#endif


