#pragma once


/// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.
#include <common/encoding/encoding.h>
#include <common/protocol/enum.h>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif

/// Forward Declarations

struct PartitionAnchor;


/// Data Structures

typedef struct PartitionAnchor {

    //

	uint8_t fieldsSet[8];
	/// UrlPointerTest is the principal of the transaction that produced this transaction.
	Url* UrlPointerTest;  //`json:"urlPointerTest,omitempty" form:"urlPointerTest" query:"urlPointerTest" validate:"required"`
	Bytes BytesTest;  //`json:"bytesTest,omitempty" form:"bytesTest" query:"bytesTest" validate:"required"`
	String StringTest;  //`json:"stringTest,omitempty" form:"stringTest" query:"stringTest" validate:"required"`
	/// UIntTest is the major block index, or zero.
	UVarInt UIntTest;  //`json:"uintTest,omitempty" form:"uintTest" query:"uintTest" validate:"required"`
	/// UVarIntTest is the minor block index.
	UVarInt UVarIntTest;  //`json:"uvarIntTest,omitempty" form:"uvarIntTest" query:"uvarIntTest" validate:"required"`
	/// HashTest is the anchor of the root chain.
	Bytes32 HashTest;  //`json:"hashTest,omitempty" form:"hashTest" query:"hashTest" validate:"required"`
	/// TxIdRepeatablePointerTest is the transaction hashes of synthetic transactions received out of order.
    size_t TxIdRepeatablePointerTest_length;
	Bytes32** TxIdRepeatablePointerTest;  //`json:"txIdRepeatablePointerTest,omitempty" form:"txIdRepeatablePointerTest" query:"txIdRepeatablePointerTest" validate:"required"`
	/// BigIntTest is the amount of acme tokens burnt in the transaction.
	BigInt BigIntTest;  //`json:"bigIntTest,omitempty" form:"bigIntTest" query:"bigIntTest" validate:"required"`
	Bytes extraData[8];

    ///pseudo helper functions
//    //TransactionType (*GetType)();
//    int (*BinarySize)(const struct PartitionAnchor *);
//    bool (*Equal)(const struct PartitionAnchor*, const struct PartitionAnchor*);
//    //int (*Copy)(struct PartitionAnchor*, const struct PartitionAnchor*);
//    Error (*MarshalBinary)(const struct PartitionAnchor*, Bytes *outData);
//    Error (*UnmarshalBinary)(struct PartitionAnchor*,const Bytes* data);
//    Error (*MarshalJSON)(const struct PartitionAnchor *v, Bytes *outData);
//    Error (*UnmarshalJSON)(struct PartitionAnchor*,const Bytes* data);
} PartitionAnchor;


/// Comparisons

static bool PartitionAnchor_equal(const PartitionAnchor *v, const PartitionAnchor *u) {
        {
            const Url* a = v->UrlPointerTest;
            const Url* b = u->UrlPointerTest;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bytes *a = &v->BytesTest;
            const Bytes *b = &u->BytesTest;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }
        {
            const String *a = &v->StringTest;
            const String *b = &u->StringTest;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->UIntTest;
            const UVarInt *b = &u->UIntTest;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->UVarIntTest;
            const UVarInt *b = &u->UVarIntTest;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bytes32 *a = &v->HashTest;
            const Bytes32 *b = &u->HashTest;
            if ( !Bytes32_equal(a,b) ) {
                return false;
            }
        }
        if ( v->TxIdRepeatablePointerTest_length == u->TxIdRepeatablePointerTest_length ) {
            for ( int i = 0; i < v->TxIdRepeatablePointerTest_length; ++i ) {
                const Bytes32* a = v->TxIdRepeatablePointerTest[i];
                const Bytes32* b = u->TxIdRepeatablePointerTest[i];
                if ( !Bytes32_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        {
            const BigInt *a = &v->BigIntTest;
            const BigInt *b = &u->BigIntTest;
            if ( !BigInt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Marshaled Binary Size Calculations

ACME_API int PartitionAnchor_binarySize(const PartitionAnchor *v) {
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
    Error e = Error_init(0);
        {
            const Url* a = v->UrlPointerTest;
            b = Url_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
        {
            const Bytes *a = &v->BytesTest;
            b = Bytes_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
        {
            const String *a = &v->StringTest;
            b = String_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
        {
            const UVarInt *a = &v->UIntTest;
            b = UVarInt_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
        {
            const UVarInt *a = &v->UVarIntTest;
            b = UVarInt_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
        {
            const Bytes32 *a = &v->HashTest;
            b = Bytes32_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }
        for ( int i = 0; i < v->TxIdRepeatablePointerTest_length; ++i ) {
            const Bytes32* a = v->TxIdRepeatablePointerTest[i];

            b = Bytes32_binarySize(v->TxIdRepeatablePointerTest[i]);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            b += n;
        }
        {
            const BigInt *a = &v->BigIntTest;
            b = BigInt_binarySize(a);
            if ( IsError(ErrorCode(b)) ) {
                return b;
            }
            n += b;
        }

    return n;
}


/// Binary Marshalers

ACME_API Error PartitionAnchor_marshalBinary(PartitionAnchor *v, Bytes *outData) {
    return ErrorCode(ErrorNotImplemented);
}


/// Binary Unmarshalers

ACME_API int marshalerWritePartitionAnchor(Marshaler *m, PartitionAnchor*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;
        {
            const Url* a = v->UrlPointerTest;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bytes *a = &v->BytesTest;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteBytes(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const String *a = &v->StringTest;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->UIntTest;

            b = marshalerWriteField(m, 4);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->UVarIntTest;

            b = marshalerWriteField(m, 5);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bytes32 *a = &v->HashTest;

            b = marshalerWriteField(m, 6);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteBytes32(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        for ( int i = 0; i < v->TxIdRepeatablePointerTest_length; ++i ) {
            const Bytes32* a = v->TxIdRepeatablePointerTest[i];

            b = marshalerWriteField(m, 7);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteBytes32(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        {
            const BigInt *a = &v->BigIntTest;

            b = marshalerWriteField(m, 8);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteBigInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Marshaling



/// JSON Unmarshaling




static PartitionAnchor PartitionAnchor_init(PartitionAnchor *v) {
    PartitionAnchor init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = PartitionAnchor_type;
//    init.BinarySize = PartitionAnchor_binarySize;
//    init.Equal = PartitionAnchor_equal;
    //init.Copy = PartitionAnchor_copy;
//    init.MarshalBinary = PartitionAnchor_marshalBinary;
//    init.UnmarshalBinary = PartitionAnchor_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}


#ifdef __cplusplus
}
#endif


