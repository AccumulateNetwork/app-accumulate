#ifndef _ACCUMULATE_TRANSACTION_HEADER_
#define _ACCUMULATE_TRANSACTION_HEADER_


/// GENERATED BY go run ./tools/cmd/genmarshal. DO NOT EDIT.
#include <common/encoding/encoding.h>
#include <common/protocol/enum.h>
#include <common/protocol/unions.h>
#ifdef __cplusplus
extern "C" {
#endif

#ifdef ACME_STATIC
#define ACME_API static
#else
#define ACME_API extern
#endif

/// Forward Declarations

struct AccountAuth;

struct AccumulateDataEntry;

struct AcmeOracle;

struct AnchorMetadata;

struct AuthorityEntry;

struct BlockEntry;

struct ChainMetadata;

struct ChainParams;

struct FactomDataEntry;

struct FactomDataEntryWrapper;

struct FeeSchedule;

struct IndexEntry;

struct KeySpec;

struct KeySpecParams;

struct NetworkDefinition;

struct NetworkGlobals;

struct Object;

struct PartitionInfo;

struct Rational;

struct Route;

struct RouteOverride;

struct RoutingTable;

struct TokenIssuerProof;

struct TokenRecipient;

struct TxIdSet;

struct ValidatorInfo;

struct ValidatorPartitionInfo;


/// Data Structures

typedef struct AccountAuth {
    
    //

	//uint8_t fieldsSet[1];
    size_t Authorities_length;
	AuthorityEntry* Authorities;  //`json:"authorities,omitempty" form:"authorities" query:"authorities" validate:"required"`
	//Bytes extraData[1];

} AccountAuth;

typedef struct AccumulateDataEntry {
    
    DataEntryType Type;
    
    //

	//uint8_t fieldsSet[2];
    size_t Data_length;
	Bytes* Data;  //`json:"data,omitempty" form:"data" query:"data" validate:"required"`
	//Bytes extraData[2];

} AccumulateDataEntry;

typedef struct AcmeOracle {
    
    //

	//uint8_t fieldsSet[1];
	UVarInt Price;  //`json:"price,omitempty" form:"price" query:"price" validate:"required"`
	//Bytes extraData[1];

} AcmeOracle;

typedef struct AnchorMetadata {
    
    //
    ChainMetadata _ChainMetadata; //"Embedded" struct

	//uint8_t fieldsSet[6];
	ChainMetadata _ChainMetadata;
	Url Account;  //`json:"account,omitempty" form:"account" query:"account" validate:"required"`
	UVarInt Index;  //`json:"index,omitempty" form:"index" query:"index" validate:"required"`
	UVarInt SourceIndex;  //`json:"sourceIndex,omitempty" form:"sourceIndex" query:"sourceIndex" validate:"required"`
	UVarInt SourceBlock;  //`json:"sourceBlock,omitempty" form:"sourceBlock" query:"sourceBlock" validate:"required"`
	Bytes Entry;  //`json:"entry,omitempty" form:"entry" query:"entry" validate:"required"`
	//Bytes extraData[6];

} AnchorMetadata;

typedef struct AuthorityEntry {
    
    //

	//uint8_t fieldsSet[2];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	/// Disabled disables auth checks for this authority, allowing anyone to sign for it.
	Bool Disabled;  //`json:"disabled,omitempty" form:"disabled" query:"disabled" validate:"required"`
	//Bytes extraData[2];

} AuthorityEntry;

typedef struct BlockEntry {
    
    //

	//uint8_t fieldsSet[3];
	Url Account;  //`json:"account,omitempty" form:"account" query:"account" validate:"required"`
	String Chain;  //`json:"chain,omitempty" form:"chain" query:"chain" validate:"required"`
	UVarInt Index;  //`json:"index" form:"index" query:"index" validate:"required"`
	//Bytes extraData[3];

} BlockEntry;

typedef struct ChainMetadata {
    
    //

	//uint8_t fieldsSet[2];
	String Name;  //`json:"name,omitempty" form:"name" query:"name" validate:"required"`
	ChainType Type;  //`json:"type,omitempty" form:"type" query:"type" validate:"required"`
	//Bytes extraData[2];

} ChainMetadata;

typedef struct ChainParams {
    
    //

	//uint8_t fieldsSet[2];
	Bytes Data;  //`json:"data,omitempty" form:"data" query:"data" validate:"required"`
	Bool IsUpdate;  //`json:"isUpdate,omitempty" form:"isUpdate" query:"isUpdate" validate:"required"`
	//Bytes extraData[2];

} ChainParams;

typedef struct FactomDataEntry {
    
    //

	//
	Bytes32 AccountId;  //`json:"accountId,omitempty" form:"accountId" query:"accountId" validate:"required"`
	Bytes Data;  //`json:"data,omitempty" form:"data" query:"data" validate:"required"`
    size_t ExtIds_length;
	Bytes* ExtIds;  //`json:"extIds,omitempty" form:"extIds" query:"extIds" validate:"required"`
	//

} FactomDataEntry;

typedef struct FactomDataEntryWrapper {
    
    DataEntryType Type;
    
    //

	//uint8_t fieldsSet[2];
	FactomDataEntry _FactomDataEntry;
	//Bytes extraData[2];

} FactomDataEntryWrapper;

typedef struct FeeSchedule {
    
    //

	//uint8_t fieldsSet[1];
	/// CreateIdentitySliding is the sliding fee schedule for creating an ADI. The first entry is the cost of a one-character ADI, the second is the cost of a two-character ADI, etc.
    size_t CreateIdentitySliding_length;
	Fee* CreateIdentitySliding;  //`json:"createIdentitySliding,omitempty" form:"createIdentitySliding" query:"createIdentitySliding" validate:"required"`
	//Bytes extraData[1];

} FeeSchedule;

typedef struct IndexEntry {
    
    //

	//uint8_t fieldsSet[5];
	/// Source is the index of the chain from which an anchor was taken.
	UVarInt Source;  //`json:"source,omitempty" form:"source" query:"source" validate:"required"`
	/// Anchor is the index of the chain into which the anchor was added. Omit when indexing the root anchor chain.
	UVarInt Anchor;  //`json:"anchor,omitempty" form:"anchor" query:"anchor" validate:"required"`
	/// BlockIndex is the index of the block. Only include when indexing the root anchor chain.
	UVarInt BlockIndex;  //`json:"blockIndex,omitempty" form:"blockIndex" query:"blockIndex" validate:"required"`
	/// BlockTime is the start time of the block. Only include when indexing the root anchor chain.
	Time BlockTime;  //`json:"blockTime,omitempty" form:"blockTime" query:"blockTime" validate:"required"`
	/// RootIndexIndex is the index of the root anchor index chain entry. Only include when indexing the anchor ledger for a major block.
	UVarInt RootIndexIndex;  //`json:"rootIndexIndex,omitempty" form:"rootIndexIndex" query:"rootIndexIndex" validate:"required"`
	//Bytes extraData[5];

} IndexEntry;

typedef struct KeySpec {
    
    //

	//uint8_t fieldsSet[3];
	Bytes PublicKeyHash;  //`json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	UVarInt LastUsedOn;  //`json:"lastUsedOn,omitempty" form:"lastUsedOn" query:"lastUsedOn" validate:"required"`
	Url Delegate;  //`json:"delegate,omitempty" form:"delegate" query:"delegate" validate:"required"`
	//Bytes extraData[3];

} KeySpec;

typedef struct KeySpecParams {
    
    //

	//uint8_t fieldsSet[2];
	Bytes KeyHash;  //`json:"keyHash,omitempty" form:"keyHash" query:"keyHash" validate:"required"`
	Url Delegate;  //`json:"delegate,omitempty" form:"delegate" query:"delegate"`
	//Bytes extraData[2];

} KeySpecParams;

typedef struct NetworkDefinition {
    
    //

	//uint8_t fieldsSet[4];
	String NetworkName;  //`json:"networkName,omitempty" form:"networkName" query:"networkName" validate:"required"`
	UVarInt Version;  //`json:"version,omitempty" form:"version" query:"version" validate:"required"`
    size_t Partitions_length;
	PartitionInfo* Partitions;  //`json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required"`
    size_t Validators_length;
	ValidatorInfo* Validators;  //`json:"validators,omitempty" form:"validators" query:"validators" validate:"required"`
	//Bytes extraData[4];

} NetworkDefinition;

typedef struct NetworkGlobals {
    
    //

	//uint8_t fieldsSet[5];
	Rational OperatorAcceptThreshold;  //`json:"operatorAcceptThreshold,omitempty" form:"operatorAcceptThreshold" query:"operatorAcceptThreshold" validate:"required"`
	Rational ValidatorAcceptThreshold;  //`json:"validatorAcceptThreshold,omitempty" form:"validatorAcceptThreshold" query:"validatorAcceptThreshold" validate:"required"`
	/// MajorBlockSchedule a cron expression defining the (approximate) major blocks interval.
	String MajorBlockSchedule;  //`json:"majorBlockSchedule,omitempty" form:"majorBlockSchedule" query:"majorBlockSchedule" validate:"required"`
	/// AnchorEmptyBlocks controls whether an anchor is sent for a block if the block contains no transactions other than a directory anchor.
	Bool AnchorEmptyBlocks;  //`json:"anchorEmptyBlocks,omitempty" form:"anchorEmptyBlocks" query:"anchorEmptyBlocks" validate:"required"`
	FeeSchedule FeeSchedule;  //`json:"feeSchedule,omitempty" form:"feeSchedule" query:"feeSchedule" validate:"required"`
	//Bytes extraData[5];

} NetworkGlobals;

typedef struct Object {
    
    //

	//uint8_t fieldsSet[3];
	/// Type is the object's type.
	ObjectType Type;  //`json:"type,omitempty" form:"type" query:"type" validate:"required"`
	/// Chains lists the account's chains.
    size_t Chains_length;
	ChainMetadata* Chains;  //`json:"chains,omitempty" form:"chains" query:"chains" validate:"required"`
	/// Pending lists the account's pending transactions.
	TxIdSet Pending;  //`json:"pending,omitempty" form:"pending" query:"pending" validate:"required"`
	//Bytes extraData[3];

} Object;

typedef struct PartitionInfo {
    
    //

	//uint8_t fieldsSet[2];
	String ID;  //`json:"id,omitempty" form:"id" query:"id" validate:"required"`
	PartitionType Type;  //`json:"type,omitempty" form:"type" query:"type" validate:"required"`
	//Bytes extraData[2];

} PartitionInfo;

typedef struct Rational {
    
    //

	//uint8_t fieldsSet[2];
	UVarInt Numerator;  //`json:"numerator,omitempty" form:"numerator" query:"numerator" validate:"required"`
	UVarInt Denominator;  //`json:"denominator,omitempty" form:"denominator" query:"denominator" validate:"required"`
	//Bytes extraData[2];

} Rational;

typedef struct Route {
    
    //

	//uint8_t fieldsSet[3];
	/// Length is the prefix length.
	UVarInt Length;  //`json:"length,omitempty" form:"length" query:"length" validate:"required"`
	/// Value is the prefix value.
	UVarInt Value;  //`json:"value,omitempty" form:"value" query:"value" validate:"required"`
	String Partition;  //`json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	//Bytes extraData[3];

} Route;

typedef struct RouteOverride {
    
    //

	//uint8_t fieldsSet[2];
	Url Account;  //`json:"account,omitempty" form:"account" query:"account" validate:"required"`
	String Partition;  //`json:"partition,omitempty" form:"partition" query:"partition" validate:"required"`
	//Bytes extraData[2];

} RouteOverride;

typedef struct RoutingTable {
    
    //

	//uint8_t fieldsSet[2];
    size_t Overrides_length;
	RouteOverride* Overrides;  //`json:"overrides,omitempty" form:"overrides" query:"overrides" validate:"required"`
    size_t Routes_length;
	Route* Routes;  //`json:"routes,omitempty" form:"routes" query:"routes" validate:"required"`
	//Bytes extraData[2];

} RoutingTable;

typedef struct TokenIssuerProof {
    
    //

	//uint8_t fieldsSet[2];
	CreateToken Transaction;  //`json:"transaction,omitempty" form:"transaction" query:"transaction" validate:"required"`
	Receipt Receipt;  //`json:"receipt,omitempty" form:"receipt" query:"receipt" validate:"required"`
	//Bytes extraData[2];

} TokenIssuerProof;

typedef struct TokenRecipient {
    
    //

	//uint8_t fieldsSet[2];
	Url Url;  //`json:"url,omitempty" form:"url" query:"url" validate:"required"`
	BigInt Amount;  //`json:"amount,omitempty" form:"amount" query:"amount" validate:"required"`
	//Bytes extraData[2];

} TokenRecipient;

typedef struct TxIdSet {
    
    //

	//uint8_t fieldsSet[1];
    size_t Entries_length;
	Bytes32* Entries;  //`json:"entries,omitempty" form:"entries" query:"entries" validate:"required"`
	//Bytes extraData[1];

} TxIdSet;

typedef struct ValidatorInfo {
    
    //

	//uint8_t fieldsSet[4];
	Bytes PublicKey;  //`json:"publicKey,omitempty" form:"publicKey" query:"publicKey" validate:"required"`
	Bytes32 PublicKeyHash;  //`json:"publicKeyHash,omitempty" form:"publicKeyHash" query:"publicKeyHash" validate:"required"`
	Url Operator;  //`json:"operator,omitempty" form:"operator" query:"operator" validate:"required"`
    size_t Partitions_length;
	ValidatorPartitionInfo* Partitions;  //`json:"partitions,omitempty" form:"partitions" query:"partitions" validate:"required"`
	//Bytes extraData[4];

} ValidatorInfo;

typedef struct ValidatorPartitionInfo {
    
    //

	//uint8_t fieldsSet[2];
	String ID;  //`json:"id,omitempty" form:"id" query:"id" validate:"required"`
	Bool Active;  //`json:"active" form:"active" query:"active" validate:"required"`
	//Bytes extraData[2];

} ValidatorPartitionInfo;





ACME_API bool AccountAuth_equal(const AccountAuth *v, const AccountAuth *u);
ACME_API int unmarshalerReadAccountAuth(Unmarshaler *m, AccountAuth *v);
ACME_API int marshalerWriteAccountAuth(Marshaler *m, AccountAuth*v);
ACME_API int AccountAuth_binarySize(const AccountAuth *v);

ACME_API DataEntryType Accumulate_type(void);
ACME_API bool AccumulateDataEntry_equal(const AccumulateDataEntry *v, const AccumulateDataEntry *u);
ACME_API int unmarshalerReadAccumulateDataEntry(Unmarshaler *m, AccumulateDataEntry *v);
ACME_API int marshalerWriteAccumulateDataEntry(Marshaler *m, AccumulateDataEntry*v);
ACME_API int AccumulateDataEntry_binarySize(const AccumulateDataEntry *v);


ACME_API bool AcmeOracle_equal(const AcmeOracle *v, const AcmeOracle *u);
ACME_API int unmarshalerReadAcmeOracle(Unmarshaler *m, AcmeOracle *v);
ACME_API int marshalerWriteAcmeOracle(Marshaler *m, AcmeOracle*v);
ACME_API int AcmeOracle_binarySize(const AcmeOracle *v);


ACME_API bool AnchorMetadata_equal(const AnchorMetadata *v, const AnchorMetadata *u);
ACME_API int unmarshalerReadAnchorMetadata(Unmarshaler *m, AnchorMetadata *v);
ACME_API int marshalerWriteAnchorMetadata(Marshaler *m, AnchorMetadata*v);
ACME_API int AnchorMetadata_binarySize(const AnchorMetadata *v);


ACME_API bool AuthorityEntry_equal(const AuthorityEntry *v, const AuthorityEntry *u);
ACME_API int unmarshalerReadAuthorityEntry(Unmarshaler *m, AuthorityEntry *v);
ACME_API int marshalerWriteAuthorityEntry(Marshaler *m, AuthorityEntry*v);
ACME_API int AuthorityEntry_binarySize(const AuthorityEntry *v);


ACME_API bool BlockEntry_equal(const BlockEntry *v, const BlockEntry *u);
ACME_API int unmarshalerReadBlockEntry(Unmarshaler *m, BlockEntry *v);
ACME_API int marshalerWriteBlockEntry(Marshaler *m, BlockEntry*v);
ACME_API int BlockEntry_binarySize(const BlockEntry *v);


ACME_API bool ChainMetadata_equal(const ChainMetadata *v, const ChainMetadata *u);
ACME_API int unmarshalerReadChainMetadata(Unmarshaler *m, ChainMetadata *v);
ACME_API int marshalerWriteChainMetadata(Marshaler *m, ChainMetadata*v);
ACME_API int ChainMetadata_binarySize(const ChainMetadata *v);


ACME_API bool ChainParams_equal(const ChainParams *v, const ChainParams *u);
ACME_API int unmarshalerReadChainParams(Unmarshaler *m, ChainParams *v);
ACME_API int marshalerWriteChainParams(Marshaler *m, ChainParams*v);
ACME_API int ChainParams_binarySize(const ChainParams *v);


ACME_API bool FactomDataEntry_equal(const FactomDataEntry *v, const FactomDataEntry *u);

ACME_API DataEntryType Factom_type(void);
ACME_API bool FactomDataEntryWrapper_equal(const FactomDataEntryWrapper *v, const FactomDataEntryWrapper *u);
ACME_API int unmarshalerReadFactomDataEntryWrapper(Unmarshaler *m, FactomDataEntryWrapper *v);
ACME_API int marshalerWriteFactomDataEntryWrapper(Marshaler *m, FactomDataEntryWrapper*v);
ACME_API int FactomDataEntryWrapper_binarySize(const FactomDataEntryWrapper *v);


ACME_API bool FeeSchedule_equal(const FeeSchedule *v, const FeeSchedule *u);
ACME_API int unmarshalerReadFeeSchedule(Unmarshaler *m, FeeSchedule *v);
ACME_API int marshalerWriteFeeSchedule(Marshaler *m, FeeSchedule*v);
ACME_API int FeeSchedule_binarySize(const FeeSchedule *v);


ACME_API bool IndexEntry_equal(const IndexEntry *v, const IndexEntry *u);
ACME_API int unmarshalerReadIndexEntry(Unmarshaler *m, IndexEntry *v);
ACME_API int marshalerWriteIndexEntry(Marshaler *m, IndexEntry*v);
ACME_API int IndexEntry_binarySize(const IndexEntry *v);


ACME_API bool KeySpec_equal(const KeySpec *v, const KeySpec *u);
ACME_API int unmarshalerReadKeySpec(Unmarshaler *m, KeySpec *v);
ACME_API int marshalerWriteKeySpec(Marshaler *m, KeySpec*v);
ACME_API int KeySpec_binarySize(const KeySpec *v);


ACME_API bool KeySpecParams_equal(const KeySpecParams *v, const KeySpecParams *u);
ACME_API int unmarshalerReadKeySpecParams(Unmarshaler *m, KeySpecParams *v);
ACME_API int marshalerWriteKeySpecParams(Marshaler *m, KeySpecParams*v);
ACME_API int KeySpecParams_binarySize(const KeySpecParams *v);


ACME_API bool NetworkDefinition_equal(const NetworkDefinition *v, const NetworkDefinition *u);
ACME_API int unmarshalerReadNetworkDefinition(Unmarshaler *m, NetworkDefinition *v);
ACME_API int marshalerWriteNetworkDefinition(Marshaler *m, NetworkDefinition*v);
ACME_API int NetworkDefinition_binarySize(const NetworkDefinition *v);


ACME_API bool NetworkGlobals_equal(const NetworkGlobals *v, const NetworkGlobals *u);
ACME_API int unmarshalerReadNetworkGlobals(Unmarshaler *m, NetworkGlobals *v);
ACME_API int marshalerWriteNetworkGlobals(Marshaler *m, NetworkGlobals*v);
ACME_API int NetworkGlobals_binarySize(const NetworkGlobals *v);


ACME_API bool Object_equal(const Object *v, const Object *u);
ACME_API int unmarshalerReadObject(Unmarshaler *m, Object *v);
ACME_API int marshalerWriteObject(Marshaler *m, Object*v);
ACME_API int Object_binarySize(const Object *v);


ACME_API bool PartitionInfo_equal(const PartitionInfo *v, const PartitionInfo *u);
ACME_API int unmarshalerReadPartitionInfo(Unmarshaler *m, PartitionInfo *v);
ACME_API int marshalerWritePartitionInfo(Marshaler *m, PartitionInfo*v);
ACME_API int PartitionInfo_binarySize(const PartitionInfo *v);


ACME_API bool Rational_equal(const Rational *v, const Rational *u);
ACME_API int unmarshalerReadRational(Unmarshaler *m, Rational *v);
ACME_API int marshalerWriteRational(Marshaler *m, Rational*v);
ACME_API int Rational_binarySize(const Rational *v);


ACME_API bool Route_equal(const Route *v, const Route *u);
ACME_API int unmarshalerReadRoute(Unmarshaler *m, Route *v);
ACME_API int marshalerWriteRoute(Marshaler *m, Route*v);
ACME_API int Route_binarySize(const Route *v);


ACME_API bool RouteOverride_equal(const RouteOverride *v, const RouteOverride *u);
ACME_API int unmarshalerReadRouteOverride(Unmarshaler *m, RouteOverride *v);
ACME_API int marshalerWriteRouteOverride(Marshaler *m, RouteOverride*v);
ACME_API int RouteOverride_binarySize(const RouteOverride *v);


ACME_API bool RoutingTable_equal(const RoutingTable *v, const RoutingTable *u);
ACME_API int unmarshalerReadRoutingTable(Unmarshaler *m, RoutingTable *v);
ACME_API int marshalerWriteRoutingTable(Marshaler *m, RoutingTable*v);
ACME_API int RoutingTable_binarySize(const RoutingTable *v);


ACME_API bool TokenIssuerProof_equal(const TokenIssuerProof *v, const TokenIssuerProof *u);
ACME_API int unmarshalerReadTokenIssuerProof(Unmarshaler *m, TokenIssuerProof *v);
ACME_API int marshalerWriteTokenIssuerProof(Marshaler *m, TokenIssuerProof*v);
ACME_API int TokenIssuerProof_binarySize(const TokenIssuerProof *v);


ACME_API bool TokenRecipient_equal(const TokenRecipient *v, const TokenRecipient *u);
ACME_API int unmarshalerReadTokenRecipient(Unmarshaler *m, TokenRecipient *v);
ACME_API int marshalerWriteTokenRecipient(Marshaler *m, TokenRecipient*v);
ACME_API int TokenRecipient_binarySize(const TokenRecipient *v);


ACME_API bool TxIdSet_equal(const TxIdSet *v, const TxIdSet *u);
ACME_API int unmarshalerReadTxIdSet(Unmarshaler *m, TxIdSet *v);
ACME_API int marshalerWriteTxIdSet(Marshaler *m, TxIdSet*v);
ACME_API int TxIdSet_binarySize(const TxIdSet *v);


ACME_API bool ValidatorInfo_equal(const ValidatorInfo *v, const ValidatorInfo *u);
ACME_API int unmarshalerReadValidatorInfo(Unmarshaler *m, ValidatorInfo *v);
ACME_API int marshalerWriteValidatorInfo(Marshaler *m, ValidatorInfo*v);
ACME_API int ValidatorInfo_binarySize(const ValidatorInfo *v);


ACME_API bool ValidatorPartitionInfo_equal(const ValidatorPartitionInfo *v, const ValidatorPartitionInfo *u);
ACME_API int unmarshalerReadValidatorPartitionInfo(Unmarshaler *m, ValidatorPartitionInfo *v);
ACME_API int marshalerWriteValidatorPartitionInfo(Marshaler *m, ValidatorPartitionInfo*v);
ACME_API int ValidatorPartitionInfo_binarySize(const ValidatorPartitionInfo *v);



#endif

#ifdef _ACCUMULATE_TRANSACTION_SOURCE_

/// JSON Marshaling





/// Comparisons
bool AccountAuth_equal(const AccountAuth *v, const AccountAuth *u) {
        if ( v->Authorities_length == u->Authorities_length ) {
            for ( size_t i = 0; i < v->Authorities_length; ++i ) {
                const AuthorityEntry* a = &v->Authorities[i];
                const AuthorityEntry* b = &u->Authorities[i];
                if ( !AuthorityEntry_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the account auth from bytes as a unsigned varint.
ACME_API int unmarshalerReadAccountAuth(Unmarshaler *m, AccountAuth *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Authorities_length = 0;
        while ( field == 1 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Authorities_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Authorities = (AuthorityEntry*)unmarshalerAlloc(m, v->Authorities_length*sizeof(AuthorityEntry));
        for ( size_t i = 0; i < v->Authorities_length; ++i ) {
            AuthorityEntry* a = &v->Authorities[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadAuthorityEntry(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteAccountAuth(Marshaler *m, AccountAuth*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        for ( int i = 0; i < v->Authorities_length; ++i ) {
            const AuthorityEntry* a = &v->Authorities[i];
            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = AuthorityEntry_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteAuthorityEntry(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static AccountAuth AccountAuth_init(AccountAuth *v) {
    AccountAuth init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = AccountAuth_type;
//    init.BinarySize = AccountAuth_binarySize;
//    init.Equal = AccountAuth_equal;
    //init.Copy = AccountAuth_copy;
//    init.MarshalBinary = AccountAuth_marshalBinary;
//    init.UnmarshalBinary = AccountAuth_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}


DataEntryType Accumulate_type(void) { return DataEntryTypeAccumulate; }


/// Comparisons
bool AccumulateDataEntry_equal(const AccumulateDataEntry *v, const AccumulateDataEntry *u) {
        {
            const DataEntryType *a = &v->Type;
            const DataEntryType *b = &u->Type;
            if ( !DataEntryType_equal(a,b) ) {
                return false;
            }
        }
        if ( v->Data_length == u->Data_length ) {
            for ( size_t i = 0; i < v->Data_length; ++i ) {
                const Bytes* a = &v->Data[i];
                const Bytes* b = &u->Data[i];
                if ( !Bytes_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the accumulate data entry from bytes as a unsigned varint.
ACME_API int unmarshalerReadAccumulateDataEntry(Unmarshaler *m, AccumulateDataEntry *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    uint64_t unionType = DataEntryTypeAccumulate;
    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        DataEntryType *a = &v->Type;

        
        //ensure we are the correct union type
        uint64_t type = 0;
        b = unmarshalerReadUInt(m,&type);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( type != unionType ) {
            return ErrorInvalidObject;
        }
        
        n += b;
    }
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Data_length = 0;
        while ( field == 2 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 2 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Data_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Data = (Bytes*)unmarshalerAlloc(m, v->Data_length*sizeof(Bytes));
        for ( size_t i = 0; i < v->Data_length; ++i ) {
            Bytes* a = &v->Data[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 2 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadBytes(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteAccumulateDataEntry(Marshaler *m, AccumulateDataEntry*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    v->Type = DataEntryTypeAccumulate;
    
        {
            const DataEntryType *a = &v->Type;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteDataEntryType(m,*a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        for ( int i = 0; i < v->Data_length; ++i ) {
            const Bytes* a = &v->Data[i];
            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = Bytes_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteBytes(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static AccumulateDataEntry AccumulateDataEntry_init(AccumulateDataEntry *v) {
    AccumulateDataEntry init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = AccumulateDataEntry_type;
//    init.BinarySize = AccumulateDataEntry_binarySize;
//    init.Equal = AccumulateDataEntry_equal;
    //init.Copy = AccumulateDataEntry_copy;
//    init.MarshalBinary = AccumulateDataEntry_marshalBinary;
//    init.UnmarshalBinary = AccumulateDataEntry_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool AcmeOracle_equal(const AcmeOracle *v, const AcmeOracle *u) {
        {
            const UVarInt *a = &v->Price;
            const UVarInt *b = &u->Price;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the acme oracle from bytes as a unsigned varint.
ACME_API int unmarshalerReadAcmeOracle(Unmarshaler *m, AcmeOracle *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Price;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteAcmeOracle(Marshaler *m, AcmeOracle*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const UVarInt *a = &v->Price;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static AcmeOracle AcmeOracle_init(AcmeOracle *v) {
    AcmeOracle init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = AcmeOracle_type;
//    init.BinarySize = AcmeOracle_binarySize;
//    init.Equal = AcmeOracle_equal;
    //init.Copy = AcmeOracle_copy;
//    init.MarshalBinary = AcmeOracle_marshalBinary;
//    init.UnmarshalBinary = AcmeOracle_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool AnchorMetadata_equal(const AnchorMetadata *v, const AnchorMetadata *u) {
        {
            const ChainMetadata *a = &v->ChainMetadata;
            const ChainMetadata *b = &u->ChainMetadata;
            if ( !ChainMetadata_equal(a,b) ) {
                return false;
            }
        }
        {
            const Url* a = &v->Account;
            const Url* b = &u->Account;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->Index;
            const UVarInt *b = &u->Index;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->SourceIndex;
            const UVarInt *b = &u->SourceIndex;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->SourceBlock;
            const UVarInt *b = &u->SourceBlock;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bytes *a = &v->Entry;
            const Bytes *b = &u->Entry;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the anchor metadata from bytes as a unsigned varint.
ACME_API int unmarshalerReadAnchorMetadata(Unmarshaler *m, AnchorMetadata *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    e = unmarshalerReadChainMetadata(m, &v->_ChainMetadata);
    if ( IsError(e) ) {
        return e.code;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        ChainMetadata *a = &v->ChainMetadata;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadChainMetadata(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Account;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Index;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 4 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->SourceIndex;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 5 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->SourceBlock;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 6 ) {
            return ErrorInvalidField;
        }
        Bytes *a = &v->Entry;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBytes(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteAnchorMetadata(Marshaler *m, AnchorMetadata*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    e = marshalerWriteChainMetadata(m, &v->_ChainMetadata);
    if ( IsError(e) ) {
        return e.code;
    }
    
        {
            const ChainMetadata *a = &v->ChainMetadata;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteChainMetadata(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Url* a = &v->Account;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->Index;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->SourceIndex;

            b = marshalerWriteField(m, 4);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->SourceBlock;

            b = marshalerWriteField(m, 5);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bytes *a = &v->Entry;

            b = marshalerWriteField(m, 6);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBytes(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static AnchorMetadata AnchorMetadata_init(AnchorMetadata *v) {
    AnchorMetadata init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = AnchorMetadata_type;
//    init.BinarySize = AnchorMetadata_binarySize;
//    init.Equal = AnchorMetadata_equal;
    //init.Copy = AnchorMetadata_copy;
//    init.MarshalBinary = AnchorMetadata_marshalBinary;
//    init.UnmarshalBinary = AnchorMetadata_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool AuthorityEntry_equal(const AuthorityEntry *v, const AuthorityEntry *u) {
        {
            const Url* a = &v->Url;
            const Url* b = &u->Url;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bool *a = &v->Disabled;
            const Bool *b = &u->Disabled;
            if ( !Bool_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the authority entry from bytes as a unsigned varint.
ACME_API int unmarshalerReadAuthorityEntry(Unmarshaler *m, AuthorityEntry *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Url;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Bool *a = &v->Disabled;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBool(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteAuthorityEntry(Marshaler *m, AuthorityEntry*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Url* a = &v->Url;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bool *a = &v->Disabled;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBool(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static AuthorityEntry AuthorityEntry_init(AuthorityEntry *v) {
    AuthorityEntry init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = AuthorityEntry_type;
//    init.BinarySize = AuthorityEntry_binarySize;
//    init.Equal = AuthorityEntry_equal;
    //init.Copy = AuthorityEntry_copy;
//    init.MarshalBinary = AuthorityEntry_marshalBinary;
//    init.UnmarshalBinary = AuthorityEntry_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool BlockEntry_equal(const BlockEntry *v, const BlockEntry *u) {
        {
            const Url* a = &v->Account;
            const Url* b = &u->Account;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        {
            const String *a = &v->Chain;
            const String *b = &u->Chain;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->Index;
            const UVarInt *b = &u->Index;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the block entry from bytes as a unsigned varint.
ACME_API int unmarshalerReadBlockEntry(Unmarshaler *m, BlockEntry *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Account;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        String *a = &v->Chain;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Index;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteBlockEntry(Marshaler *m, BlockEntry*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Url* a = &v->Account;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const String *a = &v->Chain;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->Index;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static BlockEntry BlockEntry_init(BlockEntry *v) {
    BlockEntry init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = BlockEntry_type;
//    init.BinarySize = BlockEntry_binarySize;
//    init.Equal = BlockEntry_equal;
    //init.Copy = BlockEntry_copy;
//    init.MarshalBinary = BlockEntry_marshalBinary;
//    init.UnmarshalBinary = BlockEntry_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool ChainMetadata_equal(const ChainMetadata *v, const ChainMetadata *u) {
        {
            const String *a = &v->Name;
            const String *b = &u->Name;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const ChainType *a = &v->Type;
            const ChainType *b = &u->Type;
            if ( !ChainType_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the chain metadata from bytes as a unsigned varint.
ACME_API int unmarshalerReadChainMetadata(Unmarshaler *m, ChainMetadata *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        String *a = &v->Name;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        ChainType *a = &v->Type;

        
        b = unmarshalerReadChainType(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteChainMetadata(Marshaler *m, ChainMetadata*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const String *a = &v->Name;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const ChainType *a = &v->Type;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteChainType(m,*a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static ChainMetadata ChainMetadata_init(ChainMetadata *v) {
    ChainMetadata init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = ChainMetadata_type;
//    init.BinarySize = ChainMetadata_binarySize;
//    init.Equal = ChainMetadata_equal;
    //init.Copy = ChainMetadata_copy;
//    init.MarshalBinary = ChainMetadata_marshalBinary;
//    init.UnmarshalBinary = ChainMetadata_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool ChainParams_equal(const ChainParams *v, const ChainParams *u) {
        {
            const Bytes *a = &v->Data;
            const Bytes *b = &u->Data;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bool *a = &v->IsUpdate;
            const Bool *b = &u->IsUpdate;
            if ( !Bool_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the chain params from bytes as a unsigned varint.
ACME_API int unmarshalerReadChainParams(Unmarshaler *m, ChainParams *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Bytes *a = &v->Data;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBytes(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Bool *a = &v->IsUpdate;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBool(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteChainParams(Marshaler *m, ChainParams*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Bytes *a = &v->Data;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBytes(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bool *a = &v->IsUpdate;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBool(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static ChainParams ChainParams_init(ChainParams *v) {
    ChainParams init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = ChainParams_type;
//    init.BinarySize = ChainParams_binarySize;
//    init.Equal = ChainParams_equal;
    //init.Copy = ChainParams_copy;
//    init.MarshalBinary = ChainParams_marshalBinary;
//    init.UnmarshalBinary = ChainParams_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool FactomDataEntry_equal(const FactomDataEntry *v, const FactomDataEntry *u) {
        {
            const Bytes32 *a = &v->AccountId;
            const Bytes32 *b = &u->AccountId;
            if ( !Bytes32_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bytes *a = &v->Data;
            const Bytes *b = &u->Data;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }
        if ( v->ExtIds_length == u->ExtIds_length ) {
            for ( size_t i = 0; i < v->ExtIds_length; ++i ) {
                const Bytes* a = &v->ExtIds[i];
                const Bytes* b = &u->ExtIds[i];
                if ( !Bytes_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the factom data entry from bytes as a unsigned varint.




/// JSON Marshaling


/// JSON Unmarshaling


static FactomDataEntry FactomDataEntry_init(FactomDataEntry *v) {
    FactomDataEntry init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = FactomDataEntry_type;
//    init.BinarySize = FactomDataEntry_binarySize;
//    init.Equal = FactomDataEntry_equal;
    //init.Copy = FactomDataEntry_copy;
//    init.MarshalBinary = FactomDataEntry_marshalBinary;
//    init.UnmarshalBinary = FactomDataEntry_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}


DataEntryType Factom_type(void) { return DataEntryTypeFactom; }


/// Comparisons
bool FactomDataEntryWrapper_equal(const FactomDataEntryWrapper *v, const FactomDataEntryWrapper *u) {
        {
            const DataEntryType *a = &v->Type;
            const DataEntryType *b = &u->Type;
            if ( !DataEntryType_equal(a,b) ) {
                return false;
            }
        }
        {
            const FactomDataEntry *a = &v->FactomDataEntry;
            const FactomDataEntry *b = &u->FactomDataEntry;
            if ( !FactomDataEntry_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the factom data entry wrapper from bytes as a unsigned varint.
ACME_API int unmarshalerReadFactomDataEntryWrapper(Unmarshaler *m, FactomDataEntryWrapper *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    uint64_t unionType = DataEntryTypeFactom;
    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        DataEntryType *a = &v->Type;

        
        //ensure we are the correct union type
        uint64_t type = 0;
        b = unmarshalerReadUInt(m,&type);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( type != unionType ) {
            return ErrorInvalidObject;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        FactomDataEntry *a = &v->FactomDataEntry;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteFactomDataEntryWrapper(Marshaler *m, FactomDataEntryWrapper*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    v->Type = DataEntryTypeFactom;
    
        {
            const DataEntryType *a = &v->Type;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteDataEntryType(m,*a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const FactomDataEntry *a = &v->FactomDataEntry;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteFactomDataEntry(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static FactomDataEntryWrapper FactomDataEntryWrapper_init(FactomDataEntryWrapper *v) {
    FactomDataEntryWrapper init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = FactomDataEntryWrapper_type;
//    init.BinarySize = FactomDataEntryWrapper_binarySize;
//    init.Equal = FactomDataEntryWrapper_equal;
    //init.Copy = FactomDataEntryWrapper_copy;
//    init.MarshalBinary = FactomDataEntryWrapper_marshalBinary;
//    init.UnmarshalBinary = FactomDataEntryWrapper_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool FeeSchedule_equal(const FeeSchedule *v, const FeeSchedule *u) {
        if ( v->CreateIdentitySliding_length == u->CreateIdentitySliding_length ) {
            for ( size_t i = 0; i < v->CreateIdentitySliding_length; ++i ) {
                const Fee* a = &v->CreateIdentitySliding[i];
                const Fee* b = &u->CreateIdentitySliding[i];
                if ( !Fee_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the fee schedule from bytes as a unsigned varint.
ACME_API int unmarshalerReadFeeSchedule(Unmarshaler *m, FeeSchedule *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->CreateIdentitySliding_length = 0;
        while ( field == 1 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->CreateIdentitySliding_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->CreateIdentitySliding = (Fee*)unmarshalerAlloc(m, v->CreateIdentitySliding_length*sizeof(Fee));
        for ( size_t i = 0; i < v->CreateIdentitySliding_length; ++i ) {
            Fee* a = &v->CreateIdentitySliding[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadFee(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteFeeSchedule(Marshaler *m, FeeSchedule*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        for ( int i = 0; i < v->CreateIdentitySliding_length; ++i ) {
            const Fee* a = &v->CreateIdentitySliding[i];
            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = Fee_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteFee(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static FeeSchedule FeeSchedule_init(FeeSchedule *v) {
    FeeSchedule init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = FeeSchedule_type;
//    init.BinarySize = FeeSchedule_binarySize;
//    init.Equal = FeeSchedule_equal;
    //init.Copy = FeeSchedule_copy;
//    init.MarshalBinary = FeeSchedule_marshalBinary;
//    init.UnmarshalBinary = FeeSchedule_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool IndexEntry_equal(const IndexEntry *v, const IndexEntry *u) {
        {
            const UVarInt *a = &v->Source;
            const UVarInt *b = &u->Source;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->Anchor;
            const UVarInt *b = &u->Anchor;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->BlockIndex;
            const UVarInt *b = &u->BlockIndex;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const Time* a = &v->BlockTime;
            const Time* b = &u->BlockTime;
            if ( !Time_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->RootIndexIndex;
            const UVarInt *b = &u->RootIndexIndex;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the index entry from bytes as a unsigned varint.
ACME_API int unmarshalerReadIndexEntry(Unmarshaler *m, IndexEntry *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Source;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Anchor;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->BlockIndex;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 4 ) {
            return ErrorInvalidField;
        }
        Time* a = &v->BlockTime;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadTime(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 5 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->RootIndexIndex;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteIndexEntry(Marshaler *m, IndexEntry*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const UVarInt *a = &v->Source;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->Anchor;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->BlockIndex;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Time* a = &v->BlockTime;

            b = marshalerWriteField(m, 4);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteTime(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->RootIndexIndex;

            b = marshalerWriteField(m, 5);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static IndexEntry IndexEntry_init(IndexEntry *v) {
    IndexEntry init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = IndexEntry_type;
//    init.BinarySize = IndexEntry_binarySize;
//    init.Equal = IndexEntry_equal;
    //init.Copy = IndexEntry_copy;
//    init.MarshalBinary = IndexEntry_marshalBinary;
//    init.UnmarshalBinary = IndexEntry_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool KeySpec_equal(const KeySpec *v, const KeySpec *u) {
        {
            const Bytes *a = &v->PublicKeyHash;
            const Bytes *b = &u->PublicKeyHash;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->LastUsedOn;
            const UVarInt *b = &u->LastUsedOn;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const Url* a = &v->Delegate;
            const Url* b = &u->Delegate;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the key spec from bytes as a unsigned varint.
ACME_API int unmarshalerReadKeySpec(Unmarshaler *m, KeySpec *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Bytes *a = &v->PublicKeyHash;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBytes(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->LastUsedOn;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Delegate;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteKeySpec(Marshaler *m, KeySpec*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Bytes *a = &v->PublicKeyHash;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBytes(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->LastUsedOn;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Url* a = &v->Delegate;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static KeySpec KeySpec_init(KeySpec *v) {
    KeySpec init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = KeySpec_type;
//    init.BinarySize = KeySpec_binarySize;
//    init.Equal = KeySpec_equal;
    //init.Copy = KeySpec_copy;
//    init.MarshalBinary = KeySpec_marshalBinary;
//    init.UnmarshalBinary = KeySpec_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool KeySpecParams_equal(const KeySpecParams *v, const KeySpecParams *u) {
        {
            const Bytes *a = &v->KeyHash;
            const Bytes *b = &u->KeyHash;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }
        {
            const Url* a = &v->Delegate;
            const Url* b = &u->Delegate;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the key spec params from bytes as a unsigned varint.
ACME_API int unmarshalerReadKeySpecParams(Unmarshaler *m, KeySpecParams *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Bytes *a = &v->KeyHash;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBytes(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Delegate;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteKeySpecParams(Marshaler *m, KeySpecParams*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Bytes *a = &v->KeyHash;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBytes(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Url* a = &v->Delegate;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static KeySpecParams KeySpecParams_init(KeySpecParams *v) {
    KeySpecParams init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = KeySpecParams_type;
//    init.BinarySize = KeySpecParams_binarySize;
//    init.Equal = KeySpecParams_equal;
    //init.Copy = KeySpecParams_copy;
//    init.MarshalBinary = KeySpecParams_marshalBinary;
//    init.UnmarshalBinary = KeySpecParams_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool NetworkDefinition_equal(const NetworkDefinition *v, const NetworkDefinition *u) {
        {
            const String *a = &v->NetworkName;
            const String *b = &u->NetworkName;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->Version;
            const UVarInt *b = &u->Version;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        if ( v->Partitions_length == u->Partitions_length ) {
            for ( size_t i = 0; i < v->Partitions_length; ++i ) {
                const PartitionInfo* a = &v->Partitions[i];
                const PartitionInfo* b = &u->Partitions[i];
                if ( !PartitionInfo_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        if ( v->Validators_length == u->Validators_length ) {
            for ( size_t i = 0; i < v->Validators_length; ++i ) {
                const ValidatorInfo* a = &v->Validators[i];
                const ValidatorInfo* b = &u->Validators[i];
                if ( !ValidatorInfo_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the network definition from bytes as a unsigned varint.
ACME_API int unmarshalerReadNetworkDefinition(Unmarshaler *m, NetworkDefinition *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        String *a = &v->NetworkName;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Version;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Partitions_length = 0;
        while ( field == 3 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 3 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Partitions_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Partitions = (PartitionInfo*)unmarshalerAlloc(m, v->Partitions_length*sizeof(PartitionInfo));
        for ( size_t i = 0; i < v->Partitions_length; ++i ) {
            PartitionInfo* a = &v->Partitions[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 3 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadPartitionInfo(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Validators_length = 0;
        while ( field == 4 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 4 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Validators_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Validators = (ValidatorInfo*)unmarshalerAlloc(m, v->Validators_length*sizeof(ValidatorInfo));
        for ( size_t i = 0; i < v->Validators_length; ++i ) {
            ValidatorInfo* a = &v->Validators[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 4 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadValidatorInfo(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteNetworkDefinition(Marshaler *m, NetworkDefinition*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const String *a = &v->NetworkName;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->Version;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        for ( int i = 0; i < v->Partitions_length; ++i ) {
            const PartitionInfo** a = &v->Partitions[i];
            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = PartitionInfo_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWritePartitionInfo(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        for ( int i = 0; i < v->Validators_length; ++i ) {
            const ValidatorInfo** a = &v->Validators[i];
            b = marshalerWriteField(m, 4);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = ValidatorInfo_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteValidatorInfo(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static NetworkDefinition NetworkDefinition_init(NetworkDefinition *v) {
    NetworkDefinition init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = NetworkDefinition_type;
//    init.BinarySize = NetworkDefinition_binarySize;
//    init.Equal = NetworkDefinition_equal;
    //init.Copy = NetworkDefinition_copy;
//    init.MarshalBinary = NetworkDefinition_marshalBinary;
//    init.UnmarshalBinary = NetworkDefinition_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool NetworkGlobals_equal(const NetworkGlobals *v, const NetworkGlobals *u) {
        {
            const Rational *a = &v->OperatorAcceptThreshold;
            const Rational *b = &u->OperatorAcceptThreshold;
            if ( !Rational_equal(a,b) ) {
                return false;
            }
        }
        {
            const Rational *a = &v->ValidatorAcceptThreshold;
            const Rational *b = &u->ValidatorAcceptThreshold;
            if ( !Rational_equal(a,b) ) {
                return false;
            }
        }
        {
            const String *a = &v->MajorBlockSchedule;
            const String *b = &u->MajorBlockSchedule;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bool *a = &v->AnchorEmptyBlocks;
            const Bool *b = &u->AnchorEmptyBlocks;
            if ( !Bool_equal(a,b) ) {
                return false;
            }
        }
        {
            const FeeSchedule* a = &v->FeeSchedule;
            const FeeSchedule* b = &u->FeeSchedule;
            if ( !FeeSchedule_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the network globals from bytes as a unsigned varint.
ACME_API int unmarshalerReadNetworkGlobals(Unmarshaler *m, NetworkGlobals *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Rational *a = &v->OperatorAcceptThreshold;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadRational(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Rational *a = &v->ValidatorAcceptThreshold;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadRational(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        String *a = &v->MajorBlockSchedule;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 4 ) {
            return ErrorInvalidField;
        }
        Bool *a = &v->AnchorEmptyBlocks;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBool(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 5 ) {
            return ErrorInvalidField;
        }
        FeeSchedule* a = &v->FeeSchedule;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadFeeSchedule(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteNetworkGlobals(Marshaler *m, NetworkGlobals*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Rational *a = &v->OperatorAcceptThreshold;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteRational(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Rational *a = &v->ValidatorAcceptThreshold;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteRational(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const String *a = &v->MajorBlockSchedule;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bool *a = &v->AnchorEmptyBlocks;

            b = marshalerWriteField(m, 4);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBool(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const FeeSchedule* a = &v->FeeSchedule;

            b = marshalerWriteField(m, 5);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteFeeSchedule(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static NetworkGlobals NetworkGlobals_init(NetworkGlobals *v) {
    NetworkGlobals init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = NetworkGlobals_type;
//    init.BinarySize = NetworkGlobals_binarySize;
//    init.Equal = NetworkGlobals_equal;
    //init.Copy = NetworkGlobals_copy;
//    init.MarshalBinary = NetworkGlobals_marshalBinary;
//    init.UnmarshalBinary = NetworkGlobals_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool Object_equal(const Object *v, const Object *u) {
        {
            const ObjectType *a = &v->Type;
            const ObjectType *b = &u->Type;
            if ( !ObjectType_equal(a,b) ) {
                return false;
            }
        }
        if ( v->Chains_length == u->Chains_length ) {
            for ( size_t i = 0; i < v->Chains_length; ++i ) {
                const ChainMetadata* a = &v->Chains[i];
                const ChainMetadata* b = &u->Chains[i];
                if ( !ChainMetadata_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        {
            const TxIdSet *a = &v->Pending;
            const TxIdSet *b = &u->Pending;
            if ( !TxIdSet_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the object from bytes as a unsigned varint.
ACME_API int unmarshalerReadObject(Unmarshaler *m, Object *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        ObjectType *a = &v->Type;

        
        b = unmarshalerReadObjectType(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Chains_length = 0;
        while ( field == 2 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 2 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Chains_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Chains = (ChainMetadata*)unmarshalerAlloc(m, v->Chains_length*sizeof(ChainMetadata));
        for ( size_t i = 0; i < v->Chains_length; ++i ) {
            ChainMetadata* a = &v->Chains[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 2 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadChainMetadata(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        TxIdSet *a = &v->Pending;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadTxIdSet(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteObject(Marshaler *m, Object*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const ObjectType *a = &v->Type;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteObjectType(m,*a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        for ( int i = 0; i < v->Chains_length; ++i ) {
            const ChainMetadata* a = &v->Chains[i];
            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = ChainMetadata_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteChainMetadata(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        {
            const TxIdSet *a = &v->Pending;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteTxIdSet(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static Object Object_init(Object *v) {
    Object init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = Object_type;
//    init.BinarySize = Object_binarySize;
//    init.Equal = Object_equal;
    //init.Copy = Object_copy;
//    init.MarshalBinary = Object_marshalBinary;
//    init.UnmarshalBinary = Object_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool PartitionInfo_equal(const PartitionInfo *v, const PartitionInfo *u) {
        {
            const String *a = &v->ID;
            const String *b = &u->ID;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const PartitionType *a = &v->Type;
            const PartitionType *b = &u->Type;
            if ( !PartitionType_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the partition info from bytes as a unsigned varint.
ACME_API int unmarshalerReadPartitionInfo(Unmarshaler *m, PartitionInfo *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        String *a = &v->ID;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        PartitionType *a = &v->Type;

        
        b = unmarshalerReadPartitionType(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWritePartitionInfo(Marshaler *m, PartitionInfo*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const String *a = &v->ID;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const PartitionType *a = &v->Type;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWritePartitionType(m,*a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static PartitionInfo PartitionInfo_init(PartitionInfo *v) {
    PartitionInfo init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = PartitionInfo_type;
//    init.BinarySize = PartitionInfo_binarySize;
//    init.Equal = PartitionInfo_equal;
    //init.Copy = PartitionInfo_copy;
//    init.MarshalBinary = PartitionInfo_marshalBinary;
//    init.UnmarshalBinary = PartitionInfo_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool Rational_equal(const Rational *v, const Rational *u) {
        {
            const UVarInt *a = &v->Numerator;
            const UVarInt *b = &u->Numerator;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->Denominator;
            const UVarInt *b = &u->Denominator;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the rational from bytes as a unsigned varint.
ACME_API int unmarshalerReadRational(Unmarshaler *m, Rational *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Numerator;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Denominator;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteRational(Marshaler *m, Rational*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const UVarInt *a = &v->Numerator;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->Denominator;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static Rational Rational_init(Rational *v) {
    Rational init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = Rational_type;
//    init.BinarySize = Rational_binarySize;
//    init.Equal = Rational_equal;
    //init.Copy = Rational_copy;
//    init.MarshalBinary = Rational_marshalBinary;
//    init.UnmarshalBinary = Rational_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool Route_equal(const Route *v, const Route *u) {
        {
            const UVarInt *a = &v->Length;
            const UVarInt *b = &u->Length;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const UVarInt *a = &v->Value;
            const UVarInt *b = &u->Value;
            if ( !UVarInt_equal(a,b) ) {
                return false;
            }
        }
        {
            const String *a = &v->Partition;
            const String *b = &u->Partition;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the route from bytes as a unsigned varint.
ACME_API int unmarshalerReadRoute(Unmarshaler *m, Route *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Length;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        UVarInt *a = &v->Value;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUVarInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        String *a = &v->Partition;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteRoute(Marshaler *m, Route*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const UVarInt *a = &v->Length;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const UVarInt *a = &v->Value;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUVarInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const String *a = &v->Partition;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static Route Route_init(Route *v) {
    Route init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = Route_type;
//    init.BinarySize = Route_binarySize;
//    init.Equal = Route_equal;
    //init.Copy = Route_copy;
//    init.MarshalBinary = Route_marshalBinary;
//    init.UnmarshalBinary = Route_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool RouteOverride_equal(const RouteOverride *v, const RouteOverride *u) {
        {
            const Url* a = &v->Account;
            const Url* b = &u->Account;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        {
            const String *a = &v->Partition;
            const String *b = &u->Partition;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the route override from bytes as a unsigned varint.
ACME_API int unmarshalerReadRouteOverride(Unmarshaler *m, RouteOverride *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Account;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        String *a = &v->Partition;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteRouteOverride(Marshaler *m, RouteOverride*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Url* a = &v->Account;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const String *a = &v->Partition;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static RouteOverride RouteOverride_init(RouteOverride *v) {
    RouteOverride init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = RouteOverride_type;
//    init.BinarySize = RouteOverride_binarySize;
//    init.Equal = RouteOverride_equal;
    //init.Copy = RouteOverride_copy;
//    init.MarshalBinary = RouteOverride_marshalBinary;
//    init.UnmarshalBinary = RouteOverride_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool RoutingTable_equal(const RoutingTable *v, const RoutingTable *u) {
        if ( v->Overrides_length == u->Overrides_length ) {
            for ( size_t i = 0; i < v->Overrides_length; ++i ) {
                const RouteOverride* a = &v->Overrides[i];
                const RouteOverride* b = &u->Overrides[i];
                if ( !RouteOverride_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }
        if ( v->Routes_length == u->Routes_length ) {
            for ( size_t i = 0; i < v->Routes_length; ++i ) {
                const Route* a = &v->Routes[i];
                const Route* b = &u->Routes[i];
                if ( !Route_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the routing table from bytes as a unsigned varint.
ACME_API int unmarshalerReadRoutingTable(Unmarshaler *m, RoutingTable *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Overrides_length = 0;
        while ( field == 1 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Overrides_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Overrides = (RouteOverride*)unmarshalerAlloc(m, v->Overrides_length*sizeof(RouteOverride));
        for ( size_t i = 0; i < v->Overrides_length; ++i ) {
            RouteOverride* a = &v->Overrides[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadRouteOverride(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Routes_length = 0;
        while ( field == 2 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 2 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Routes_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Routes = (Route*)unmarshalerAlloc(m, v->Routes_length*sizeof(Route));
        for ( size_t i = 0; i < v->Routes_length; ++i ) {
            Route* a = &v->Routes[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 2 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadRoute(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteRoutingTable(Marshaler *m, RoutingTable*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        for ( int i = 0; i < v->Overrides_length; ++i ) {
            const RouteOverride* a = &v->Overrides[i];
            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = RouteOverride_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteRouteOverride(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }
        for ( int i = 0; i < v->Routes_length; ++i ) {
            const Route* a = &v->Routes[i];
            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = Route_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteRoute(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static RoutingTable RoutingTable_init(RoutingTable *v) {
    RoutingTable init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = RoutingTable_type;
//    init.BinarySize = RoutingTable_binarySize;
//    init.Equal = RoutingTable_equal;
    //init.Copy = RoutingTable_copy;
//    init.MarshalBinary = RoutingTable_marshalBinary;
//    init.UnmarshalBinary = RoutingTable_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool TokenIssuerProof_equal(const TokenIssuerProof *v, const TokenIssuerProof *u) {
        {
            const CreateToken* a = &v->Transaction;
            const CreateToken* b = &u->Transaction;
            if ( !CreateToken_equal(a,b) ) {
                return false;
            }
        }
        {
            const Receipt* a = &v->Receipt;
            const Receipt* b = &u->Receipt;
            if ( !Receipt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the token issuer proof from bytes as a unsigned varint.
ACME_API int unmarshalerReadTokenIssuerProof(Unmarshaler *m, TokenIssuerProof *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        CreateToken* a = &v->Transaction;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadCreateToken(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Receipt* a = &v->Receipt;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadReceipt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteTokenIssuerProof(Marshaler *m, TokenIssuerProof*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const CreateToken* a = &v->Transaction;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteCreateToken(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Receipt* a = &v->Receipt;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteReceipt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static TokenIssuerProof TokenIssuerProof_init(TokenIssuerProof *v) {
    TokenIssuerProof init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = TokenIssuerProof_type;
//    init.BinarySize = TokenIssuerProof_binarySize;
//    init.Equal = TokenIssuerProof_equal;
    //init.Copy = TokenIssuerProof_copy;
//    init.MarshalBinary = TokenIssuerProof_marshalBinary;
//    init.UnmarshalBinary = TokenIssuerProof_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool TokenRecipient_equal(const TokenRecipient *v, const TokenRecipient *u) {
        {
            const Url* a = &v->Url;
            const Url* b = &u->Url;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        {
            const BigInt *a = &v->Amount;
            const BigInt *b = &u->Amount;
            if ( !BigInt_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the token recipient from bytes as a unsigned varint.
ACME_API int unmarshalerReadTokenRecipient(Unmarshaler *m, TokenRecipient *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Url;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        BigInt *a = &v->Amount;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBigInt(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteTokenRecipient(Marshaler *m, TokenRecipient*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Url* a = &v->Url;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const BigInt *a = &v->Amount;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBigInt(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static TokenRecipient TokenRecipient_init(TokenRecipient *v) {
    TokenRecipient init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = TokenRecipient_type;
//    init.BinarySize = TokenRecipient_binarySize;
//    init.Equal = TokenRecipient_equal;
    //init.Copy = TokenRecipient_copy;
//    init.MarshalBinary = TokenRecipient_marshalBinary;
//    init.UnmarshalBinary = TokenRecipient_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool TxIdSet_equal(const TxIdSet *v, const TxIdSet *u) {
        if ( v->Entries_length == u->Entries_length ) {
            for ( size_t i = 0; i < v->Entries_length; ++i ) {
                const Bytes32* a = &v->Entries[i];
                const Bytes32* b = &u->Entries[i];
                if ( !Bytes32_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the tx id set from bytes as a unsigned varint.
ACME_API int unmarshalerReadTxIdSet(Unmarshaler *m, TxIdSet *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Entries_length = 0;
        while ( field == 1 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Entries_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Entries = (Bytes32*)unmarshalerAlloc(m, v->Entries_length*sizeof(Bytes32));
        for ( size_t i = 0; i < v->Entries_length; ++i ) {
            Bytes32* a = &v->Entries[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 1 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadBytes32(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteTxIdSet(Marshaler *m, TxIdSet*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        for ( int i = 0; i < v->Entries_length; ++i ) {
            const Bytes32** a = &v->Entries[i];
            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = Bytes32_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteBytes32(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static TxIdSet TxIdSet_init(TxIdSet *v) {
    TxIdSet init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = TxIdSet_type;
//    init.BinarySize = TxIdSet_binarySize;
//    init.Equal = TxIdSet_equal;
    //init.Copy = TxIdSet_copy;
//    init.MarshalBinary = TxIdSet_marshalBinary;
//    init.UnmarshalBinary = TxIdSet_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool ValidatorInfo_equal(const ValidatorInfo *v, const ValidatorInfo *u) {
        {
            const Bytes *a = &v->PublicKey;
            const Bytes *b = &u->PublicKey;
            if ( !Bytes_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bytes32 *a = &v->PublicKeyHash;
            const Bytes32 *b = &u->PublicKeyHash;
            if ( !Bytes32_equal(a,b) ) {
                return false;
            }
        }
        {
            const Url* a = &v->Operator;
            const Url* b = &u->Operator;
            if ( !Url_equal(a,b) ) {
                return false;
            }
        }
        if ( v->Partitions_length == u->Partitions_length ) {
            for ( size_t i = 0; i < v->Partitions_length; ++i ) {
                const ValidatorPartitionInfo* a = &v->Partitions[i];
                const ValidatorPartitionInfo* b = &u->Partitions[i];
                if ( !ValidatorPartitionInfo_equal(a, b) ) {
                    return false;
                }
            }
        } else {
            return false;
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the validator info from bytes as a unsigned varint.
ACME_API int unmarshalerReadValidatorInfo(Unmarshaler *m, ValidatorInfo *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        Bytes *a = &v->PublicKey;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBytes(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Bytes32 *a = &v->PublicKeyHash;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBytes32(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 3 ) {
            return ErrorInvalidField;
        }
        Url* a = &v->Operator;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadUrl(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        
        uint64_t field = 0;
        Unmarshaler m2 = NewUnmarshaler(&m->buffer,&m->mempool);
        unmarshalerPeekField(&m2, &field);
        v->Partitions_length = 0;
        while ( field == 4 ) {
            b = unmarshalerReadField(&m2, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 4 ) {
                return ErrorInvalidField;
            }

            //need to read the byte block
            Bytes a;
            b = unmarshalReadBytes(&m2, &a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
            v->Partitions_length++;
            field = 0;
            unmarshalerPeekField(&m2, &field);
        }
        //now unmarshal for real...
        v->Partitions = (ValidatorPartitionInfo*)unmarshalerAlloc(m, v->Partitions_length*sizeof(ValidatorPartitionInfo));
        for ( size_t i = 0; i < v->Partitions_length; ++i ) {
            ValidatorPartitionInfo* a = &v->Partitions[i];

            b = unmarshalerReadField(m, &field);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( field != 4 ) {
                return ErrorInvalidField;
            }
            uint64_t size = 0;
            b = unmarshalerReadUInt(m,&size);
            if ( IsError(ErrorCode(b)) {
                return b;
            }

            b = unmarshalerReadValidatorPartitionInfo(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            if ( b > size ) {
                return ErrorInvalidObject;
            }
            n += b;
        }

    }
	return n;
}


ACME_API int marshalerWriteValidatorInfo(Marshaler *m, ValidatorInfo*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const Bytes *a = &v->PublicKey;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBytes(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bytes32 *a = &v->PublicKeyHash;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBytes32(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Url* a = &v->Operator;

            b = marshalerWriteField(m, 3);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteUrl(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        for ( int i = 0; i < v->Partitions_length; ++i ) {
            const ValidatorPartitionInfo** a = &v->Partitions[i];
            b = marshalerWriteField(m, 4);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            //need to identify what the size of the following will be and write those bytes.
            b = ValidatorPartitionInfo_binarySize(a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            //write size of what is to follow
            b = marshalerWriteUInt(m, b);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            b = marshalerWriteValidatorPartitionInfo(m, a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static ValidatorInfo ValidatorInfo_init(ValidatorInfo *v) {
    ValidatorInfo init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = ValidatorInfo_type;
//    init.BinarySize = ValidatorInfo_binarySize;
//    init.Equal = ValidatorInfo_equal;
    //init.Copy = ValidatorInfo_copy;
//    init.MarshalBinary = ValidatorInfo_marshalBinary;
//    init.UnmarshalBinary = ValidatorInfo_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}



/// Comparisons
bool ValidatorPartitionInfo_equal(const ValidatorPartitionInfo *v, const ValidatorPartitionInfo *u) {
        {
            const String *a = &v->ID;
            const String *b = &u->ID;
            if ( !String_equal(a,b) ) {
                return false;
            }
        }
        {
            const Bool *a = &v->Active;
            const Bool *b = &u->Active;
            if ( !Bool_equal(a,b) ) {
                return false;
            }
        }

    return true;
}



/// Binary Marshalers
/// Binary Unmarshalers
// UnmarshalBinary unmarshals the validator partition info from bytes as a unsigned varint.
ACME_API int unmarshalerReadValidatorPartitionInfo(Unmarshaler *m, ValidatorPartitionInfo *v) {
	CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 1 ) {
            return ErrorInvalidField;
        }
        String *a = &v->ID;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadString(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
    {
        uint64_t field = 0;
        b = unmarshalerReadField(m, &field);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        if ( field != 2 ) {
            return ErrorInvalidField;
        }
        Bool *a = &v->Active;
        uint64_t size = 0;
        b = unmarshalerReadUInt(m,&size);
        if ( IsError(ErrorCode(b)) ) {
            return b;
        }

        
        b = unmarshalerReadBool(m,a);
        if ( IsError(ErrorCode(b))) {
            return b;
        }
        
        n += b;
    }
	return n;
}


ACME_API int marshalerWriteValidatorPartitionInfo(Marshaler *m, ValidatorPartitionInfo*v) {
    CHECK_ERROR_INT(m)
    CHECK_ERROR_INT(v)
    int n = 0;
    int b = 0;

    
        {
            const String *a = &v->ID;

            b = marshalerWriteField(m, 1);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteString(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }
        {
            const Bool *a = &v->Active;

            b = marshalerWriteField(m, 2);
            if ( IsError(ErrorCode(b))) {
                return b;
            }
            b = marshalerWriteBool(m,a);
            if ( IsError(ErrorCode(b))) {
                return b;
            }

            n += b;
        }


    return n;
}


/// JSON Marshaling


/// JSON Unmarshaling


static ValidatorPartitionInfo ValidatorPartitionInfo_init(ValidatorPartitionInfo *v) {
    ValidatorPartitionInfo init;
    memset((void*)&init, 0, sizeof(init));

//    init.GetType = ValidatorPartitionInfo_type;
//    init.BinarySize = ValidatorPartitionInfo_binarySize;
//    init.Equal = ValidatorPartitionInfo_equal;
    //init.Copy = ValidatorPartitionInfo_copy;
//    init.MarshalBinary = ValidatorPartitionInfo_marshalBinary;
//    init.UnmarshalBinary = ValidatorPartitionInfo_unmarshalBinary;
//    

    if ( v ) {
        *v = init;
    }
    return init;
}

#endif

#ifdef __cplusplus
}
#endif


